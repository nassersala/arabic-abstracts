                                          c 2016 IEEE. Personal use of this material is permitted. Permission from IEEE must be obtained for all
                                         other uses, in any current or future media, including reprinting/republishing this material for advertising
                                         or promotional purposes, creating new collective works, for resale or redistribution to servers or lists, or
                                              reuse of any copyrighted component of this work in other works. DOI: 10.1109/DSD.2016.24
                                                                                             .
                                         A. Ablak and I. Damaj, HTCC: Haskell to Handel-C Compiler, The 19th EUROMICRO Conference on
                                                Digital System Design, IEEE, Limassol, Cyprus, August 31–September, 2016. P 192–199.

                                                                                   https://doi.org/10.1109/DSD.2016.24

                                             HTCC: Haskell to Handel-C Hardware Compiler
arXiv:1907.07764v1 [cs.PL] 10 Jul 2019




                                                                                      Ahmed B. Ablak and Issam Damaj
                                                                                Electrical and Computer Engineering Department
                                                                                         American University of Kuwait
                                                                                                Salmiya, Kuwait
                                                                                   Email: {s00015070, idamaj}@auk.edu.kw


                                            Abstract—Functional programming languages, such as              beyond behavioral VHDL and the other standard tools. The
                                         Haskell, enable simple, concise, and correct-by-construction       area witnessed the emergence of programming languages and
                                         hardware development. HTCC compiles a subset of Haskell to         tools such as Handel-C [3], SystemC [4], Matlab HDL Coder,
                                         Handel-C language with hardware output. Moreover, HTCC
                                         generates VHDL, Verilog, EDIF, and SystemC programs. The           LabVIEW, etc. All the modern co-design tools enable the inte-
                                         design of HTCC compiler includes lexical, syntax and semantic      gration and partitioning of computations into communicating
                                         analyzers. HTCC automates a transformational derivation            hardware and software subsystems.
                                         methodology to rapidly produce hardware that maps onto Field          Handel-C is a high-level language with hardware output.
                                         Programmable Gate Arrays (FPGAs) . HTCC is generated               Handel-C is based on ANSI C; it is extended to the theory of
                                         using ANTLR compiler-compiler tool and supports an effective
                                         integrated development environment. This paper presents the        communication sequential processes (CSP) and the concurrent
                                         design rationale and the implementation of HTCC. Several           programming language (OCCAM) [5]. Moreover, Handel-C
                                         sample generations of first-class and higher-order functions are   has the ability to provide both parallel and sequential imple-
                                         presented. In-addition, a compilation case-study is presented      mentations. Handel-C can target different FPGA types. Recent
                                         for the XTEA cipher. The investigation comprises a thorough        research effort has been on automating hardware generation
                                         evaluation and performance analysis. The targeted FPGAs
                                         include Cyclone II, Stratix IV, and Virtex-6 from Altera and       to target Handel-C and hardware in general starting from
                                         Xilinx.                                                            functional specifications, such as, Haskell [6]–[9].
                                                                                                               Haskell is a purely functional programming language that
                                                               I. I NTRODUCTION                             utilizes functions to construct programs. Utilizing Haskell
                                            FPGAs are famous and widely used reconfigurable com-            functions is presumed to have no side effects, as the eval-
                                         puting (RC) systems. FPGAs have become very popular in             uation order of the functions is independent [10]. Modern
                                         research and industrial applications in different fields, such     functional languages are characterized by being strongly typed,
                                         as, security, signal processing etc. FPGAs evolved from being      concise, clear, lazy, and easy to insure correctness. With no
                                         limited in functionality and speed to become high-performance      doubt, developing hardware circuits based on the functional
                                         processors. Example FPGAs include Stratix from Altera and          programming paradigm is a promising and modern topic under
                                         Virtex from Xilinx [1], [2]. The flexibility of FPGAs, that are    investigation [11]–[13]. Much research effort has been done
                                         sometimes described as seas-of-gates, enable the development       to benefit from the advantages of functional programming
                                         of software paradigms to rapidly reconfigure hardware almost       languages in hardware design including Lava [14], Hawk [15],
                                         instantly.                                                         [16], Hydra [17], HML [18], MHDL [19], DDD system [20],
                                            Recently, there has been considerable focus on the devel-       SAFL [21], MuFP [22], Ruby [23], and Form [24].
                                         opment of high-level synthesis (HLS) and rapid prototyping            HTCC compiles a subset of Haskell to Handel-C, in addi-
                                         hardware/software co-design tools. The targets of co-design        tion to automatically generating VHDL, Verilog, EDIF, and
                                         tools are high design productivity, simplicity, reduced time-to-   SystemC. The design of HTCC compiler includes lexical,
                                         prototype, correctness, to name a few. Co-design tools include     syntax and semantic analyzers. The compiler is generated
                                         converting algorithmic behaviors into digital circuits that can    using ANTLR based-on a subset of Haskell grammar. HTCC
                                         map onto FPGAs. High-level co-design tools are currently           Integrated Development Environment (IDE) produces a variety
of analysis and schematic files. HTCC successfully connects
to external tools, such as, DK Design Suite, Altera Quartus,
and ModelSim. The developed compiler targets several FPGA
types, and Altera DE2-70 and DE4 FPGA boards. The targeted
area of application is cryptography, namely, the XTEA cipher.
   The paper is organized so that Section II presents the
rapid prototyping methodology adopted by HTCC. Section III
details the HTCC construction including the compiler and IDE
designs. The compiler implementation is presented in Section
IV. Sections V and VI present the compilation approach of
first-class and higher-order functions and a case-study from
cryptography. A thorough analysis and evaluation is presented
in Section VII. Section VIII concludes the paper and sets the
ground for future works.
                                                                     Fig. 1. The transformational derivation and refinement methodology.
                     II. BACKGROUND
   HTCC adopts the transformational derivation and refine-
                                                                  process Store stores a communication construct in a simple or
ment methodology of Abdallah et. al [8], [25]. The adopted
                                                                  composite variable [9].
methodology refines functional specifications into parallel
                                                                     The methodology also supports a rich set of refined higher-
hardware implementations in Handel-C. Several case-studies
                                                                  order functions, such as, map, zip, zipwith, etc. The refinement
for the methodology were carried out by Damaj et. al [9], [26]–
                                                                  of higher-order functions to processes could be done in stream
[28], however the implementations did not include a compiler
                                                                  or vector settings, or a combination of them. In Handel-C,
that automates the refinement procedure.
                                                                  datatypes are refined to structures (struct), while processes
   Figure 1 depicts the step-wise refinement procedure, where
                                                                  are refined to macro procedures [9]. Handel-C compiler gen-
functional specifications are refined to hardware. The adopted
                                                                  erates the required hardware circuits that can be mapped onto
methodology is systematic in the sense that it is carried out
                                                                  FPGAs.
using the following step-by-step procedure:
   • Specify the algorithm in a functional setting relying on                     III. C OMPILER C ONSTRUCTION
      higher-order functions as the main building constructs        HTCC is a compiler that automates the presented refinement
      wherever necessary.                                         methodology. The presented version of HTCC Integrated De-
   • Apply the predefined set of rules to create the corre-       velopment Environment (IDE) supports the following:
      sponding CSP networks according to a chosen degree of         • Compiles a subset of Haskell to Handel-C
      parallelism.                                                  • Automatically connects to the DK Design Suite from
   • Write the equivalent Handel-C code and complete the
                                                                       Mentor Graphics to run the Handel-C Compiler; it ver-
      hardware compilation.                                            ifies, generates, and analyzes the corresponding VHDL,
   The refinement steps are aided by different compilers and           Verilog, EDIF, or SystemC code
integrated development environments. HTCC automates the             • Automatically connects to Glasgow Haskell Compiler
development process including the background run of exist-             (GHC) to run and test the Haskell code
ing FPGA vendor interfaces and Haskell, Handel-C, VHDL,             • Automatically connects to Altera Quartus II to run, test,
Verilog, EDIF, and SystemC compilers.                                  analyze hardware designs; place and route; produce bit
   The adopted methodology refines both datatypes and func-            files; and target specific FPGAs and FPGA boards.
tions. Datatypes are refined to Items, Streams, and Vectors to      • Provides an easy-to-use, rich, and modern development
create communicating entities based-on the message passing             environment
technique. The Item corresponds to a basic type, such as an
Integer data type , and it is to be communicated on a single      A. Compiler Design using ANTLR
communicating channel. The Stream is a purely sequential             HTCC is developed using the compiler-compiler tool
method of communicating a list of values. The Vector is a         ANTLR. ANTLR provides an easy-to-use compiler construc-
refinement of a simple list of items that communicates the        tion structure; ANTLR is efficient, reliable, and effective [26].
entire structure in parallel [9].                                 ANTLR uses an adaptive parsing technique that provides
   In addition, the methodology refines functions to commu-       runtime grammar analysis [29]. Moreover, ANTLR uses the
nicating processes. The refinement comprises a library of         Extended BackusNaur Form (EBNF). The efficiency and ef-
standard processes, such as, Produce and Store that aid the       fectiveness of utilizing ANTLR is primarily due to its ability to
communication of refined datatypes. The Produce process is        support direct left-recursion, side-effecting actions (mutators)
used to produce values on the channels of a certain commu-        and predictions from the corresponding grammar [30].
nication construct (Item, Stream, Vector, etc.). These values        Figure 2 demonstrates the state machine diagram of HTCC
are to be received and manipulated by another processes. The      compilation procedure. The Lexical Analyzer analyzes the
input Haskell code by producing a numbered list of lexemes.       for add3 is as follows:
In addition, the Lexical Analyzer divides the code based on the
                                                                  macro proc add3 (itemIn, itemOut){
provided grammar to prepare it for the syntax analysis. The
                                                                  typeof itemIn.message x;
Lexical Analyzer removes all white space between tokens and
                                                                  itemIn.channel ? x;
ignores any input with comment symbol ”–”.
                                                                  itemOut.channel ! x+3;
                                                                  }




               Fig. 2. HTCC compiler state machine.

   The syntax analyzer is also generated using ANTLR, where
a new parse tree is constructed every compilation. ANTLR
provides the required Java library to construct parse trees and
to walk through them starting on the leftmost side. During the
walk-through, the program being compiled is checked for any                         Fig. 3. Code generation of items
errors based-on the provided grammar to ANTLR.
   The third stage of HTCC compiler is the semantic analysis,        It is very important to notice that add3 function can be
where all types of all functions are checked and stored in        utilized for list processing. The generation correspondence is
a table for further processing. Semantic Analysis checks the      shown in Figure 4.
types of inputs and outputs of each function. The semantic                        vector add3 :: [Int] → [Int]
analyzer walks through the parse tree nodes using ANTLR’s                       vector add3 x = map(add3) x
tree walker. If any datatype is found to be not supported or
mismatched, HTCC terminates the compilation processes and         The corresponding Handel-C code includes a version of add3
reports the error.                                                based on items; the generic implementation of the parallel
   After a successful semantic analysis check, HTCC continues     version of the higher-order function map (VMAP); the imple-
to the intermediate code generation and then to the final code    mentation of function vector add3 that invokes VMAP macro;
generation. In the intermediate stage, all input and output       and a main function that calls vector add3 with its inputs,
interface buses and macros are generated. Then, the number        outputs, and the number of elements in each vector. The
of connections among macros is determined and passed to           parallel instances of add3 are replicated using the par operator
the final generation stage. During the final compilation stage,   in Handel-C. The generated code is as follows:
both Handel-C bus interfaces and Handel-C main method are         macro proc add3 (itemIn, itemOut){
generated. Moreover, the connections among all macros are         typeof itemIn.message x;f
generated. The current version of HTCC does not include an        itemIn.channel ? x;
optimization stage.                                               itemOut.channel ! (x+3);}
   Figure 3 depicts the correspondence used to generate
Handel-C macros from Haskell functions. An example Haskell        macro proc VMAP(vectorIn,vectorOut,n,F){
function is as follows:                                           typeof(n) c;
                                                                  par(c=0;c<n;c++){
                      add3 :: Int → Int
                                                                  F(vectorIn.elements[c],
                       add3 x = x + 3
                                                                  vectorOut.elements[c]);}}
  The add3 function has one input and one output, where
both are of type integer. The corresponding Handel-C macro        macro proc vector_add3 (vectorIn,vectorOut,n){
VMAP(vectorIn,vectorOut,n,add3);                                    The IDE connects HTCC Compiler to external tools, such
}                                                                as, DK Design Suite to simulate and generate VHDL, Verilog,
                                                                 EDIF, and SystemC files. In addition, the IDE connects the
void main (){                                                    compiler to Altera Quartus using the TCL commands to
..                                                               synthesize and generate timing analyses, pin assignments for
vector_add3(vector0,vector1,5);                                  FPGA boards, and generate bit files to program the targeted
..                                                               FPGAs. GHC is also connected to the IDE to execute and
}                                                                verify Haskell functions. Figure 6 shows a snapshot of the
                                                                 HTCC IDE.




                                                                                     Fig. 5. Use-Case diagram




          Fig. 4. Code generation of parallel list processing



B. IDE Design
   The technique used in the development of the IDE separates
the programming concern in structuring the code in different
Jar files. HTCC IDE adopts the iterative and incremental
design model (IIDM) [31]. In the IIDM, each component of
the IDE is developed separately as a standalone project which
allows it to be integrated into multiple projects. The IDE is
implemented using Java under Netbeans [32]. The code editor
is implemented using RSyntaxTextArea Java framework. The
IDE theme is implemented using JTattoo Java framework.
Figure 5 demonstrates the use-case diagram of HTCC IDE.
The proposed IDE supports the following:
   • Editing and storing project files
   • Highlighting and automatic code completion
   • File navigation, and allows to open multiple files simul-
                                                                                        Fig. 6. HTCC IDE
     taneously
   • Running Haskell code under GHC
   • Compiling Haskell code to Handel-C code. Accordingly                     IV. C OMPILER I MPLEMENTATION
     simulating Handel-C code and generating VHDL, EDIF,           The following subset of Haskell grammar is part of HTCC
     Verilog, and SystemC implementations.                       compiler code. Here, functions are divided into decelerations
   • Compiling the generated HDL files using Altera Quar-        (dcFun) and definitions (dFun):
     tus. Accordingly, producing analysis and FPGA mapping
     files.
                                                                         V. FIRST-CLASS AND HIGHER-ORDER
                                                                                HASKELL FUNCTIONS
                                                                     HTCC can generate both first-class and higher-order func-
                                                                  tions. First-class functions represent simple binary operations,
                                                                  while higher-order functions can take other functions as pa-
                                                                  rameters and usually are operated on lists.
                                                                  A. First-Class Functions
                                                                     A sample generation of the binary operation OR is shown
PROG : ST AT +;                                                   in the following:
STAT : dcF un;
                                                                                     or :: Int → Int → Int
dcFun : ID 0 ::0 f ormalT ype(− >) ∗ N L + dF un;
                                                                                        or a b = a .|. b
expr : expr op = (0 ∗0 |0 /0 )(DIGIT |expr)
      |exprop = (0 .&.0 |0 .||.0 )(DIGIT |expr)                   By compiling the function or under HTCC, the generated
      |exprop = (0 +0 |0 −0 )(DIGIT |expr)                        Handel-C code comprises three items - each has a message
      |(0 xor0 exprDIGIT )                                        of width 32 bits. The first two items are a and b, and the
      |(0 shif tL0 exprDIGIT )                                    third item is where the result is stored. In addition, HTCC
      |(0 shif tR0 exprDIGIT )                                    generates the macro OR. HTCC generates three interfaces that
      |mP assing(mP assing)∗                                      are input0, input1, and output0 for the inputs and output. In
      |exprmP assing                                              the main method, HTCC creates three items to produce the
      |ID∗                                                        two inputs and store the output. Similar first-class functions,
                                                                  such as, AND, XOR, ADD, SUB, DIV can be generated in a
  According to the proposed grammar an expression (expr)          similar way. To run the compiled code on the Altera DE2-70,
has multiple meanings that captures the definition of the         the following is automatically generated by HTCC.
function. expr can be any arithmetic or logic operation between   set clock = external"AD15";
two or more variables. In addition, an expression expr can        set reset = external"L8";
call other functions that take place at mPassing node. Figure     #define Item(Name, Msgtype)struct{chan Msgtype
                                                                  channel; Msgtype message;}Name
7 demonstrates the parse tree of the following function:
                                                                  unsigned 32 OUTPUT0;
                       f :: Int → Int                             interface bus_in (unsigned 32 value) INPUT0();
                        f x=x + 3                                 interface bus_in (unsigned 32 value) INPUT1();
                                                                  interface bus_out() O0(unsigned 32 o = OUTPUT0 ) ;

                                                                  macro proc OR (xItem, yItem,
                                                                  itemOut){
                                                                  typeof (xItem.message) x,y;
                                                                  item0In.channel ? x;
                                                                  item1In.channel ? y;
                                                                  itemOut.channel ! x || y;}

                                                                  void main (){
                                                                  Item(item0 , unsigned 32);
                                                                  Item(item1 , unsigned 32);
                                                                  Item(item2 , unsigned 32);
                                                                  par{
                                                                  PRODUCE(INPUT0.value , item0);
                                                                  PRODUCE(INPUT1.value , item1);
                                                                  OR(item0, item1, item2 );
                                                                  STORE(item2, OUTPUT0);}}


                                                                  B. Higher-Order Functions
                Fig. 7. The parse tree of function f.                HTCC utilizes a set of parallel and sequential versions
                                                                  of a set of higher-order functions including map, zipWith,
A subset of the lexer grammar is as following:
                                                                  foldr, etc. The following is a sample generation of a parallel
ID : [a − zA − Z]+ [0 − 9]∗ ;
                                                                  zipping of two lists with multiplication. Each list contains
NL : 0 \r0 ? 0 \n0 ;
                                                                  ten elements. The generation employs the VectorOfItems
ARROW : 0 − >0 | 0 →0 ;
                                                                  structure and the parallel version of produce and store macros.
WS : [\t]+ → SKIP ;
DIGIT : [0 − 9]+ ;                                                mul :: Int → Int → Int
COMMENT : 0 − −0 .∗? 0 \r0 ? 0 \n0 → SKIP ;                       mul x y = x ∗ y
two vectors mul :: [Int] → [Int] → [Int]                        uInt32
two vectors mul a b = zipW ith(mul) a b                         xteav1 v0 v1 sum key0 = v1 +
macro proc mul (xItem, yItem,output){                           (xor (key0 + sum) (v0 + (xor (shif tL v0 4)
typeof (xItem.message) x, y;                                    (shif tR v0 5)))
xItem.channel ? x;
yItem.channel ? y;                                                 The data type uInt32 is a user-defined unsigned integer
output.channel ! (x*y);}
                                                                with 32 bits width. A single round of XTEA generates
macro proc VZIPWITH ( vectorIn1, vectorIn2,                     the following sample main function. However, the function
vectorOut, n, F){                                               xteasround produces a macro XTEASROUND when the 32
typeof (n) c;                                                   rounds are replicated to implement the top-level function xtea.
par (c =0; c< n; c++){
F(vectorIn1.elements[c], vectorIn2.elements[c],  void main {
vectorOut.elements[c]); }}                       par{
                                                 PRODUCE(INPUT0.value, item0);
macro proc two_vectors_mul(vectorIn1,vectorIn2,
                                                 PRODUCE(INPUT1.value, item1);
vectorOut,n){
                                                 PRODUCE(INPUT2.value, item2);
VZIPWITH(vectorIn1, vectorIn2, vectorOut, 100, mul);}
                                                 PRODUCE(INPUT3.value, item3);
void main (){                                    xteav0(item0, item1, item2, item3, item4);
VectorOfItems(vector0, 10, unsigned 32);         xteasum(item3, item5);
VectorOfItems(vector1, 10, unsigned 32);
                                                 xteav1(item4, item1, item2, item5, item6);
VectorOfItems(vector2, 10, unsigned 32);
par{                                             STORE (item4, OUTPUT0);
VPRODUCE(INPUT0, vector0, 10);                   STORE (item5, OUTPUT1);
VPRODUCE(INPUT1, vector1, 10);                   STORE (item6, OUTPUT2);}}
two_vectors_mul(vector0,vector1,vector2,10);
VSTORE(vector2, OUTPUT0);}}

 VI. C ASE -S TUDY: T HE R APID P ROTOTYPING OF XTEA
                      UNDER HTCC
   To test the applicability of the developed compiler, we
use the extended tiny encryption algorithm (XTEA) as a
case-study. XTEA uses a 128-bit key to encrypt a 64-bit
block ciphertext which follows Feistel ciphers structure with
a variable number of rounds. The 128-bit plaintext is divided
into two integers V0 and V1. The key produces a set of
integer sub-keys to be distributed to the appropriate round.
XTEA is small in size, light in weight, low in power, and
a secure block cipher [33]. The following is the functional
specification of the XTEA single round under Haskell:

xteasround :: Int → uInt32 → (uInt32, uInt32) →
uInt32 → (uInt32, uInt32)
xteasround 1 sum x@(v0, v1) key0 = x
xteasround rounds sum (v0, v1) key0 = xteasround
 (rounds + 1) new sum (new v0, new v1) key where
    new v0 = xteav0 v0 v1 sum key0                              Fig. 8. A single XTEA round with its internal computational constructs. The
    new sum = xteasum sum                                       crossed square for the sum, crossed circle for an XOR, >> for a right shift,
    new v1 = xteav1 new v0 v1 new sum key0                      << for a left shift.


xteav0 :: uInt32 → uInt32 → uInt32 → uInt32 →                                 VII. A NALYSIS AND E VALUATION
uInt32                                                             The proposed compiler allows for the rapid prototyping of
xteav0 v0 v1 sum key0 = v0 +                                    hardware circuits at a high-level of abstraction based-on func-
(xor (key0+sum) (v1+(xor (shif tL v1 4) (shif tR v1 5)))        tional specifications. Functional programming enables design-
                                                                ing hardware using clear, concise, and correct-by-construction
xteasum :: uInt32 → uInt32                                      specifications. Overall, the proposed compiler translates a
xteasum sum = sum + 0x9e3779b9                                  subset of Haskell to Handel-C and thus enables the usage of
                                                                Haskell as a hardware description language for programming
xteav1    :: uInt32 → uInt32 → uInt32 → uInt32 →                FPGAs.
   HTCC adopts an effective transformational derivation ap-                                    VIII. C ONCLUSION
proach that enables the systematic development of CSP con-               HTCC is a Haskell to Handel-C hardware compiler that
currency descriptions. Accordingly, the automatic generation          targets FPGAs. HTCC automates a transformational derivation
of Handel-C code is possible and effective in generating              methodology to rapidly produce hardware circuits from func-
VHDL, EDIF, Verilof, and SystemC descriptions. The refine-            tional specifications. The adopted methodology refines func-
ment methodology provides a variety of parallelism techniques         tional programs to a formal concurrency framework, namely,
to specify the required degree of parallelism. The methodology        CSP. The methodology enables the systematic refinement of
provided HTCC with the characteristics of generating a vari-          the CSP descriptions to Handel-C; HTCC comes to make this
ety of implementations with different parallel characteristics.       process automatic. Nevertheless HTCC doesn’t produce CSP
HTCC benefited from the off-the-shelf first-order, higher-            descriptions, this is identified as a future development. The
order, and application-specific libraries provided by Damaj et        developed compiler effectively produces hardware circuits in
al. [9], [27], [28] and automated the refinement procedure.           various descriptions and languages, such as, VHDL, Verilog,
   HTCC IDE enables the testing and evaluation of both                EDIF, and SystemC. HTCC connects to a bouquet of hard-
Haskell and Handel-C code through the background connec-              ware design tools to produce a rich-set of analysis reports
tion to their native compilers. HTCC IDE offers the options           and bit-stream files that can map to different FPGAs. The
to display analysis reports supported by Quartus, such as,            paper includes a case-study from cryptography that produces
power consumption, area utilization, timing, RTL views, pin           comparable, and in some instances better results than what is
assignments, etc. Furthermore, the adopted IIDM technique             reported in the literature. Indeed, HTCC adopted a functional
allows for the rapid development and integration of the various       programming style to benefit from its simplicity, conciseness,
parts of the IDE with simplicity.                                     and correctness. Future work includes expanding the area of
   Although the use of ANTLR made the compiler implemen-              application and widening the pool of implemented Haskell
tation simple, additions are necessary. The main addition in          syntax and parallelization options.
HTCC is the semantic analyzer that was embedded into the
adopted ANTLR structure. The embedding enabled effectively                                         R EFERENCES
for type checking and error reporting using the supported              [1] Altera, “Web,” Information available from: https://www.altera.com/.
exception handling mechanism.                                          [2] Xilinx, “Web,” Information available from: http://www.xilinx.com/.
                                                                       [3] MentorGraphics, “Web,” Information available from: https://www.
   Table I presents the performance analysis results of the                mentor.com/.
XTEA cipher as generated by HTCC and tested under Cyclone              [4] P. R. Panda, “SystemC - A modeling platform supporting multiple design
II, Stratix IV and Virtex-6 FPGAs. The Cyclone II FPGA is                  abstractions,” in Proceedings of ISSS01, October 2001.
                                                                       [5] I. page, “Closing the gap between hardware and software: hardware-
part of the targeted DE2-70 board. The Stratix IV FPGA is                  software cosythesis at oxford,” in IEE Colloquium on Hardware-
part of the targeted Altera DE4 board. The Virtex-6 FPGA                   Software Cosynthesis for Reconfigurable Systems, February 1996, pp.
is a high-speed FPGA from Xilinx. The Total Number of                      200–211.
                                                                       [6] I. W. Damaj, “Higher-Level Hardware Synthesis of the KASUMI
NAND Gates as measured under DK Design Suite is 467969                     Algorithm,” Journal of Computer Science and Technology, vol. 22,
with a total of 192 clock cycles. The highest frequency                    no. 1, pp. 60–70, 2007. [Online]. Available: http://dx.doi.org/10.1007/
achieved is 648.54 MHz under Virtex-6, and the lowest power                s11390-007-9007-9
                                                                       [7] J. Hawkins and A. E. Abdallah, “Hardware synthesis of a parallel
consumption achieved is 219.62 mW under the Cyclone II. In                 jpeg decoder from its functional specification,” in Design Methods and
addition, the highest throughput is 219.3 Mbps under Xilinx                Applications for Distributed Embedded Systems. Springer, 2004, pp.
Virtex-6 FPGA.                                                             197–206.
                                                                       [8] A. E. Abdallah and J. Hawkins, “Formal behavioural synthesis of
                                                                           Handel-C parallel hardware implementation for functional specifica-
                             TABLE I                                       tions,” in Proceedings of the 36th annual Hawaii international con-
                  XTEA I MPLEMENTATION R ESULTS                            ference on system sciences. IEEE Computer Society Press, 2003, pp.
                                                                           278–288.
                             Cyclone II   Stratix IV   Virtex-6        [9] I. Damaj, “Parallel Algorithms Development for Programmable Devices
 Total logic elements        15,573 LE    1221 ALUTs   26660 Slices
                                                                           with application from cryptography,” International Journal of Parallel
 Fmax (MHz)                  183.18       513.8        648.54
                                                                           Programming, vol. 35, no. issue: 6, pp. 529–572, 1st Dec. 2007, journal
 Total Execution Time (ns)   5.46         1.95         1.52
                                                                           (Purpose), Published (Status), Elsevier Science (Publisher), New York,
 Throughput (Mbps)           61.06        171.26       219.3
                                                                           U.S.A. (Address), DOI: 10.1007/s10766-007-0046-1.
 Power consumed (mW)         219.62       888.47       912.4
                                                                      [10] S. Thompson, Haskell: The Craft of Functional Programming. Boston,
                                                                           MA, USA: Addison-Wesley Longman Publishing Co., Inc., 1997.
   As compared to the performance reported in [33]–[36], the          [11] P. Bjesse, K. Claessen, M. Sheeran, and S. Singh, “Lava: Hardware
                                                                           Design in Haskell,” in Proceedings of the Third ACM SIGPLAN
results produced by HTCC achieved the highest throughput of                International Conference on Functional Programming, ser. ICFP ’98.
219.3 Mbps under the Virtex-6 (See Table II). A behavioral                 New York, NY, USA: ACM, 1998, pp. 174–184. [Online]. Available:
implementation of the XTEA cipher under VHDL achieved                      http://doi.acm.org/10.1145/289423.289440
                                                                      [12] C. Baaij, “Cλash : from Haskell to hardware,” December 2009.
134 Mbps, however, the main purpose of the implementation                  [Online]. Available: http://essay.utwente.nl/59482/
was to achieve a compact and low-power design [33]. The               [13] A. ACOSTA, “Hardware synthesis in ForSyDe,” June 2007. [Online].
manual Handel-C (HC) implementation achieved a speed of                    Available: http://people.kth.se/∼ingo/Papers/ThesisAlfonsoAcosta2007.
                                                                           pdf
44.25 Mbps with an Fmax of 177 and an area of 720 Logic               [14] M. Sheeran, “Hardware design and functional programming: a perfect
Elements.                                                                  match.” J. UCS, vol. 11, no. 7, pp. 1135–1158, 2005.
[15] J. Launchbury, J. Lewis, and B. Cook, “On embedding a microarchitec-                               TABLE II
     tural design language within haskell,” in Proceedings of the fourth ACM    C OMPASSION AMONG SIMILAR XTEA HARDWARE IMPLEMENTATION
     SIGPLAN international conference on Functional programming. ACM
     Press, 1999, pp. 60–69.                                                    Reference         [34]         [35]           [36]        [33]
[16] J. Matthews, J. Launchbury, and B. Cook, “Specifying microprocessors       Logic elements    NA           424 LUTs       1182 LUTs   539 Slices
     in hawk,” in Proceedings of the International Conference on Computer       Fmax (MHz)        NA           NA             71.11       142.4
     Languages. IEEE, May 1998, pp. 90–101.                                     Total Exe. Time   2,48 ms      NA             14.06 ns    NA
[17] J. O’Donnell, “Hydra: hardware description in a functional language us-    Throughput        0.39 kB/s    NA             NA          134 Mbps
     ing recursion equations and high order combining forms,” in The Fusion     Reference         Manual HC    HTCC
     of Hardware Design and Verification, G. J. Milne, Ed. Amsterdam:           Logic elements    720 LE       26660 Slices
     North-Holland, 1988, pp. 309–328.                                          Fmax (MHz)        177          648.54
[18] Y. Li and M. Leeser, “HML: An innovative hardware design language
                                                                                Total Exe. Time   5.6 ns       1.52 ns
     and its translation to VHDL,” in Conference on Hardware Design
                                                                                Throughput        44.25 Mbps   219.3 Mbps
     Languages, June 1995.
[19] D. Barton, “Advanced modeling features of MHDL,” in In International
     Conference on Electronic Hardware Description Languages, January
     1995.
[20] S. Johnson and B. Bose, “DDD: A system for mechanized digital design
     derivation,” Indiana University, Indiana, Tech. Rep. 323, 1990.
[21] R. Sharp, “Higher-level hardware synthesis,” Ph.D. dissertation, Robin-
     son College University of Cambridge, Cambridge, November 2002.
[22] M. Sheeran, “muFP: a language for VLSI design,” in Proc. ACM
     Symposium on LISP and Functional Programming. ACM Press, 1984,
     pp. 104–112.
[23] G. Jones and M. Sheeran, “Circuit design in ruby,” In Formal Methods
     for VLSI design, pp. 13–70, 1990.
[24] T. Cheung and G. Hellestrand, “Multi-level equivalence in design trans-
     formation,” in Proceedings of International Conference on Computer
     Hardware Description Languages, Chiba Japan, September 1996, pp.
     559–566.
[25] A. E. Abdallah, “Functional process modelling,” Research Directions in
     Parallel Functional Programming, (Springer Verlag, October 1999), pp.
     339–360, October 1999.
[26] T. Parr, The Definitive ANTLR 4 Reference, 2nd ed.             Pragmatic
     Bookshelf, 2013.
[27] I. Damaj, “Co-designs of Parallel Rijndael,” in The International Sym-
     posium on System-on-Chip. Tampere, Finland: IEEE, 1-2 November
     2011, pp. 72–77.
[28] ——, “Parallel AES Development for Programmable Devices,” in The
     Fourth IASTED International Conference on Parallel and Distributed
     Computing and Networks, IASTED. Innsbruck - Austria: Acta Press,
     February 2009.
[29] T. Parr, Language Implementation Patterns: Create Your Own Domain-
     Specific and General Programming Languages, 1st ed.            Pragmatic
     Bookshelf, 2009.
[30] T. Parr, S. Harwell, and K. Fisher, “Adaptive LL(*) Parsing: The Power
     of Dynamic Analysis,” SIGPLAN Not., vol. 49, no. 10, pp. 579–598, Oct.
     2014. [Online]. Available: http://doi.acm.org/10.1145/2714064.2660202
[31] I. Jacobson, G. Booch, J. Rumbaugh, J. Rumbaugh, and G. Booch, The
     unified software development process. Addison-Wesley Reading, 1999,
     vol. 1.
[32] D. R. Heffelfinger, Java EE 7 Development with NetBeans 8. Packt
     Publishing Ltd, 2015.
[33] I. Damaj, S. Hamade, and H. Diab, “Efficient Tiny Hardware Cipher un-
     der Verilog,” in Proceedings of the 2008 High Performance Computing
     and Simulation Conference, 2008.
[34] M. Botta, M. Simek, and N. Mitton, “Comparison of hardware and
     software based encryption for secure communication in wireless sensor
     networks,” in Telecommunications and Signal Processing (TSP), 2013
     36th International Conference on, July 2013, pp. 6–10.
[35] P. Yalla and J. Kaps, “Lightweight Cryptography for FPGAs,” in
     International Conference on Reconfigurable Computing and FPGAs,
     2009, Dec 2009, pp. 225–230.
[36] I. A. Shweta Gaba and D. Sujata, “Design of Efficient XTEA using
     Verilog,” International Journal of Scientific and Research Publications,
     vol. 2, June 2012.
