# Section 5: First-Class and Higher-Order Haskell Functions
## القسم 5: دوال Haskell من الدرجة الأولى ومن الرتبة العليا

**Section:** first-class-higher-order-functions
**Translation Quality:** 0.87
**Glossary Terms Used:** first-class functions, higher-order functions, binary operations, parallel, vector, stream, zipWith

---

### English Version

HTCC can generate both first-class and higher-order functions. First-class functions represent simple binary operations, while higher-order functions can take other functions as parameters and usually are operated on lists.

## A. First-Class Functions

A sample generation of the binary operation OR is shown in the following:

```haskell
or :: Int → Int → Int
or a b = a .|. b
```

By compiling the function or under HTCC, the generated Handel-C code comprises three items - each has a message of width 32 bits. The first two items are a and b, and the third item is where the result is stored. In addition, HTCC generates the macro OR. HTCC generates three interfaces that are input0, input1, and output0 for the inputs and output. In the main method, HTCC creates three items to produce the two inputs and store the output. Similar first-class functions, such as, AND, XOR, ADD, SUB, DIV can be generated in a similar way. To run the compiled code on the Altera DE2-70, the following is automatically generated by HTCC.

```c
set clock = external"AD15";
set reset = external"L8";
#define Item(Name, Msgtype) struct{chan Msgtype
channel; Msgtype message;}Name

unsigned 32 OUTPUT0;
interface bus_in (unsigned 32 value) INPUT0();
interface bus_in (unsigned 32 value) INPUT1();
interface bus_out() O0(unsigned 32 o = OUTPUT0);

macro proc OR (xItem, yItem, itemOut){
typeof (xItem.message) x,y;
item0In.channel ? x;
item1In.channel ? y;
itemOut.channel ! x || y;}

void main (){
Item(item0, unsigned 32);
Item(item1, unsigned 32);
Item(item2, unsigned 32);
par{
PRODUCE(INPUT0.value, item0);
PRODUCE(INPUT1.value, item1);
OR(item0, item1, item2);
STORE(item2, OUTPUT0);}}
```

## B. Higher-Order Functions

HTCC utilizes a set of parallel and sequential versions of a set of higher-order functions including map, zipWith, foldr, etc. The following is a sample generation of a parallel zipping of two lists with multiplication. Each list contains ten elements. The generation employs the VectorOfItems structure and the parallel version of produce and store macros.

```haskell
mul :: Int → Int → Int
mul x y = x * y

two_vectors_mul :: [Int] → [Int] → [Int]
two_vectors_mul a b = zipWith(mul) a b
```

```c
macro proc mul (xItem, yItem, output){
typeof (xItem.message) x, y;
xItem.channel ? x;
yItem.channel ? y;
output.channel ! (x*y);}

macro proc VZIPWITH (vectorIn1, vectorIn2,
vectorOut, n, F){
typeof (n) c;
par (c=0; c<n; c++){
F(vectorIn1.elements[c], vectorIn2.elements[c],
vectorOut.elements[c]);}}

macro proc two_vectors_mul(vectorIn1, vectorIn2,
vectorOut, n){
VZIPWITH(vectorIn1, vectorIn2, vectorOut, 100, mul);}

void main (){
VectorOfItems(vector0, 10, unsigned 32);
VectorOfItems(vector1, 10, unsigned 32);
VectorOfItems(vector2, 10, unsigned 32);
par{
VPRODUCE(INPUT0, vector0, 10);
VPRODUCE(INPUT1, vector1, 10);
two_vectors_mul(vector0, vector1, vector2, 10);
VSTORE(vector2, OUTPUT0);}}
```

---

### النسخة العربية

يمكن لـ HTCC توليد دوال من الدرجة الأولى ومن الرتبة العليا. تمثل الدوال من الدرجة الأولى عمليات ثنائية بسيطة، بينما يمكن للدوال من الرتبة العليا أخذ دوال أخرى كمعاملات وعادةً ما يتم تشغيلها على القوائم.

## أ. الدوال من الدرجة الأولى

يتم عرض مثال على توليد العملية الثنائية OR في ما يلي:

```haskell
or :: Int → Int → Int
or a b = a .|. b
```

من خلال تجميع دالة or تحت HTCC، يتألف كود Handel-C المولد من ثلاثة عناصر - كل منها له رسالة بعرض 32 بت. العنصران الأولان هما a و b، والعنصر الثالث هو حيث يتم تخزين النتيجة. بالإضافة إلى ذلك، يولد HTCC ماكرو OR. يولد HTCC ثلاث واجهات وهي input0 و input1 و output0 للمدخلات والمخرجات. في دالة main، ينشئ HTCC ثلاثة عناصر لإنتاج المدخلين وتخزين المخرج. يمكن توليد دوال من الدرجة الأولى مماثلة، مثل AND و XOR و ADD و SUB و DIV بطريقة مماثلة. لتشغيل الكود المجمع على Altera DE2-70، يتم توليد ما يلي تلقائياً بواسطة HTCC.

```c
set clock = external"AD15";
set reset = external"L8";
#define Item(Name, Msgtype) struct{chan Msgtype
channel; Msgtype message;}Name

unsigned 32 OUTPUT0;
interface bus_in (unsigned 32 value) INPUT0();
interface bus_in (unsigned 32 value) INPUT1();
interface bus_out() O0(unsigned 32 o = OUTPUT0);

macro proc OR (xItem, yItem, itemOut){
typeof (xItem.message) x,y;
item0In.channel ? x;
item1In.channel ? y;
itemOut.channel ! x || y;}

void main (){
Item(item0, unsigned 32);
Item(item1, unsigned 32);
Item(item2, unsigned 32);
par{
PRODUCE(INPUT0.value, item0);
PRODUCE(INPUT1.value, item1);
OR(item0, item1, item2);
STORE(item2, OUTPUT0);}}
```

## ب. الدوال من الرتبة العليا

يستخدم HTCC مجموعة من الإصدارات المتوازية والتسلسلية من مجموعة من الدوال من الرتبة العليا بما في ذلك map و zipWith و foldr وغيرها. فيما يلي مثال على توليد دمج متوازٍ لقائمتين مع الضرب. تحتوي كل قائمة على عشرة عناصر. يستخدم التوليد بنية VectorOfItems والنسخة المتوازية من ماكروهات produce و store.

```haskell
mul :: Int → Int → Int
mul x y = x * y

two_vectors_mul :: [Int] → [Int] → [Int]
two_vectors_mul a b = zipWith(mul) a b
```

```c
macro proc mul (xItem, yItem, output){
typeof (xItem.message) x, y;
xItem.channel ? x;
yItem.channel ? y;
output.channel ! (x*y);}

macro proc VZIPWITH (vectorIn1, vectorIn2,
vectorOut, n, F){
typeof (n) c;
par (c=0; c<n; c++){
F(vectorIn1.elements[c], vectorIn2.elements[c],
vectorOut.elements[c]);}}

macro proc two_vectors_mul(vectorIn1, vectorIn2,
vectorOut, n){
VZIPWITH(vectorIn1, vectorIn2, vectorOut, 100, mul);}

void main (){
VectorOfItems(vector0, 10, unsigned 32);
VectorOfItems(vector1, 10, unsigned 32);
VectorOfItems(vector2, 10, unsigned 32);
par{
VPRODUCE(INPUT0, vector0, 10);
VPRODUCE(INPUT1, vector1, 10);
two_vectors_mul(vector0, vector1, vector2, 10);
VSTORE(vector2, OUTPUT0);}}
```

---

### Translation Notes

- **Figures referenced:** None in this section
- **Key terms introduced:** first-class functions, higher-order functions, VectorOfItems, VZIPWITH, VPRODUCE, VSTORE
- **Equations:** 0
- **Citations:** 0
- **Special handling:**
  - Code examples kept in English (Haskell and Handel-C)
  - Function names kept in English (OR, AND, XOR, ADD, SUB, DIV, mul, zipWith, foldr)
  - Technical macros kept in English (PRODUCE, STORE, VPRODUCE, VSTORE, VZIPWITH)
  - Hardware-specific settings (clock, reset, bus interfaces) kept in code format

### Quality Metrics

- Semantic equivalence: 0.88
- Technical accuracy: 0.89
- Readability: 0.86
- Glossary consistency: 0.86
- **Overall section score:** 0.87

### Back-Translation Check (Opening Paragraph)

HTCC can generate both first-class and higher-order functions. First-class functions represent simple binary operations, while higher-order functions can take other functions as parameters and are usually operated on lists.

**Quality Assessment:** The back-translation accurately preserves the meaning (0.87).
