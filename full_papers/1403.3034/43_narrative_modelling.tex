\subsection{Contribution: Modelling of the Narrative in CASL}
\label{sec:narrative_model}
It is a matter of choice which specification language to use to model
the dynamic system aspects: in \ModalCASL or in \CASL. Here, for the
sake of readability, we present this modelling in \CASL. We note that,
throughout the presentation, we have specialised the sort
\IdDeclLabel{\Id{Time}}{Time} gained from applying our comorphism, to
the specification given in Figure \ref{fig:casl_time}.

\subsubsection{Introducing Regions for Movement}
\label{region_for_ma}
To allow us to correctly model the extension and release of movement
authorities, we introduce the notion of a region. Regions will allow
areas of a track to be reserved and released. Such regions are
categorised by both the topological routes of a track plan, and the
release points of the release table. For example, considering the pass
through station in Figure~\ref{fig:trackplan}, we can split the
topological routes at the units outlined by the release table to gain
the possible regions of the scheme plan shown in
Figure~\ref{fig:station_regions}.

\begin{figure}[h]
\begin{small}
  \centering
  \begin{tikzpicture}[transform shape]
\node at (-0.5,0) {X};
\node at (8.5,0) {Y};
\draw [->] (0,0.7) to (1,0.7);
\RWConnector{a}{(0,0)}
\RWConnector{a1}{(1,0)}
\RWLinearUnitAbove{a}{a1}{LA1}
\RWPoint{p1}{p1cl}{p1cn}{p1cr}{(2,0)}
\RWLabelLinearUnitBelow{p1cn}{p1cl}{P1}
\RWConnector{a3}{(5,0)}
\RWLinearUnitAbove{p1cn}{a3}{PLAT2}
\RWPointReverse{p2}{p2cl}{p2cn}{p2cr}{(6,0)}
\RWLabelLinearUnitBelow{p2cn}{p2cl}{P2}
\RWConnector{b1}{(3,1)}
\RWConnector{b2}{(5,1)}
\RWLinearUnitAbove{b1}{b2}{PLAT1}
\RWConnector{b4}{(7,0)}
\RWConnector{b5}{(8,0)}
\RWLinearUnitAbove{b4}{b5}{LA2}

\RWConnector{R1a}{(0.2,-0.6)}
\RWConnector{R1b}{(2.8,-0.6)}
\draw [-] (0.2,-0.7) to (2.8,-0.7);
\RWLabelLinearUnitBelow{R1a}{R1b}{RG1}

\RWConnector{R2a}{(3.2,-0.6)}
\RWConnector{R2b}{(4.8,-0.6)}
\draw [-] (3.2,-0.7) to (4.8,-0.7);
\RWLabelLinearUnitBelow{R2a}{R2b}{RG2}

\RWConnector{R3a}{(3.2,1.6)}
\RWConnector{R3b}{(4.8,1.6)}
\draw [-] (3.2,1.7) to (4.8,1.7);
\RWLabelLinearUnitAbove{R3a}{R3b}{RG3}

\RWConnector{R4a}{(5.2,-0.6)}
\RWConnector{R4b}{(7.8,-0.6)}
\draw [-] (5.2,-0.7) to (7.8,-0.7);
\RWLabelLinearUnitBelow{R4a}{R4b}{RG4}
\end{tikzpicture}  
\end{small}
  \caption{Regions of the simple station.}
  \label{fig:station_regions}
\end{figure}

The regions are defined using the release points within the release
table\footnote{We assume that a release table exhibits the property
  that all points are released ``optimally'' from a capacity point of
  view, that is, they are released as soon as the point is cleared by
  a train if travelling towards the point, or released at the end of
  the route if travelling away from a point.} to break up a route at
the given release unit. To compute the regions of a given route $r$ we
define the function $Regions:
List[Unit] \times List[Unit] \rightarrow Set[List[Unit]]$ as:\\
\\
\begin{tabular}{lll}
$Regions([u_1, \dots, u_n], [])$ & $=$ & $ \{[u_1,  \dots, u_n]\}$ \\
$Regions([u_1, \dots, u_n], [r_1, r_2, \dots, r_m])$ & $=$ & $ \{[u_1,  \dots, u_k]\} \; \cup$ \\
 & & $Regions([u_{k+1}, \dots, u_n],[r_2,\dots, r_m])$\\
& & where $u_k = r_1$.
\end{tabular}
\\ 

\noindent We then define the regions of the given route $r$ to be
$$regions(r) = Regions(units(r),releaseTable(r))$$ where $units(r)$ is the list of
units occurring within the topological route and $releaseTable(r)$ is
the topologically ordered list of release units occurring in the
release table for route $r$. For example, considering
Figure~\ref{fig:station_regions} and the route $RX1$, we have:
$Regions([LA1,P1, PLAT1],[P1]) = \{[LA1, P1]\} \; \cup \;
Regions([PLAT1],[]) = \{[LA1, P1], [PLAT1]\}.$ Notice that as we only
apply this function to routes and their release tables, each $r_i$,
for $1 \leq i \leq m,$ is guaranteed to occur only once within the
list $u_1,u_2, \dots, u_n$. That is, the region split points will be
unique for that route.

Regions allow one to model the interlocking behaviour while taking
into account the release tables. As an example, we can see that region
$RG1$ contains all the units of routes $RX1$ and $RX2$ up to and
including the release point for $P1$ as given by the release
table. Then after this release point we gain regions $RG2$ and $RG3$
representing the remaining units from the routes respectively. Such an
approach allows, the train movements given in
Figure~\ref{fig:example_movements} to be captured as the series of
region assignments as given in Figure~\ref{fig:regions}.

\begin{figure}
\centering
\begin{footnotesize}
\begin{tabular}[h]{l|c|c}
Time &  Train A Movement Authority & Train B Movement Authority \\ \hline \hline
0 & $\{ \}$ & $\{ \}$ \\
1 & $\{RG1,RG2 \}$ & $\{ \}$ \\
2 & $\{RG1,RG2 \}$ & $\{ \}$ \\
3 & $\{RG2 \}$ & $\{ \}$ \\
4 & $\{RG2 \}$ & $\{RG1,RG3 \}$ \\
5 & $\{RG2 \}$ & $\{RG1,RG3 \}$ \\
6 & $\{RG2 \}$ & $\{RG3 \}$ \\
7 & $\{RG2 \}$ & $\{RG4 \}$ \\
8 & $\{RG2 \}$ & $\{RG4 \}$ \\
9 & $\{RG2 \}$ & $\{\}$ \\
10 & $\{RG4 \}$ & $\{\}$ \\
11 & $\{RG4 \}$ & $\{\}$ \\
12 & $\{ \}$ & $\{\}$ \\
\end{tabular}
\end{footnotesize}
\caption{Modelling movement with regions.}
\label{fig:regions}
\end{figure}

To model such regions in \CASL, we instantiate a specification
\SId{List} with the sort \Id{Unit} from \Bjoerner's DSL. We then
define a subsort of these lists called \Id{Region}. Similarly, we
capture movement authorities by instantiating the specification of
\SId{List} with
these regions and making a subsort \Id{MA}:
\begin{small}
\begin{hetcasl}
\>\=\SId{List}[\KW{sort} \IdDeclLabel{\Id{Unit}}{Unit}]
\THEN \=
\SId{List}[\KW{sort} \IdDeclLabel{\Id{Region}}{Region}]
\THEN \=\\
\> \SORT \=\IdApplLabel{\Id{Region}}{Region} \Ax{<} \=\Id{List}[\IdApplLabel{\Id{Unit}}{Unit}]\\
\> \SORT \=\IdApplLabel{\Id{MA}}{MA} \Ax{<} \=\Id{List}[\IdApplLabel{\Id{Region}}{Region}]
\end{hetcasl}
\end{small}
Next, according to the rules for movement authorities given in
Section~\ref{ssec:industry_rw}, we model the assignment of a movement
authority at a given time as a predicate
\IdDeclLabel{\Id{assigned}}{assigned} \Ax{:} \IdApplLabel{\Id{MA}}{MA}
\Ax{\times} \Id{Time}. That is, if a train is assigned a movement
authority then it is allowed to travel along the railway elements
contained within the movement authority. We then add an axiom that
states that only an empty movement authority can be assigned
initially, that is at time $0$:
\begin{small}
\begin{hetcasl}
\> \PRED \=\IdDeclLabel{\Id{assigned}}{assigned} \Ax{:} \=\IdApplLabel{\Id{MA}}{MA} \Ax{\times} \Id{Time} \\
\> \Ax{\bullet} \=\Ax{\forall} \Id{m} \Ax{:} \IdApplLabel{\Id{MA}}{MA} \Ax{\bullet} \=\Ax{\neg} \=\Id{m} \Ax{=} \=\Ax{[}\Ax{]} \Ax{\Rightarrow} \Ax{\neg} \IdApplLabel{\Id{assigned}}{assigned}(\=\Id{m}, \IdApplLabel{\Ax{0}}{0}) \`{\small{}\KW{\%}(\HetsLabel{no\Ax{\_}ma\Ax{\_}0}{no:ma:0})\KW{\%}}
\end{hetcasl}
\end{small}
\noindent Similarly, to model the fact that a train can be granted a
movement authority at any time, we add an axiom that states the empty
movement authority is always available for extension:
\begin{small}
\begin{hetcasl}
\> \Ax{\bullet} \=\Ax{\forall} \Id{t} \Ax{:} \Id{Time} \Ax{\bullet} \IdApplLabel{\Id{assigned}}{assigned}(\=\Ax{[}\Ax{]} \Id{as} \IdApplLabel{\Id{MA}}{MA}, \Id{t}) 
\`{\small{}\KW{\%}(\Ax{[}\Ax{]}\_assigned\_at\_ all\_times)\KW{\%}}
\end{hetcasl}
\end{small}
\noindent We then add an axiom that states when the predicate
\IdDeclLabel{\Id{assigned}}{assigned} can hold for non empty lists. To
simplify the definition, we make use of predicates
\IdDeclLabel{\Id{canExtend}}{canExtend} \Ax{:}
\IdApplLabel{\Id{MA}}{MA} \Ax{\times} \Id{Time} and
\IdDeclLabel{\Id{canReduce}}{canReduce} \Ax{:}
\IdApplLabel{\Id{MA}}{MA} \Ax{\times} \Id{Time} whose definitions we
discuss next. The axiom given below allows for movement authorities at
some time $suc(t)$ to remain assigned as they were at time $t$, become
extended from time $t$ and also to reduce from time $t$. It also
states that only for one of these possibilities can occur for a given
movement authority at a given time. This definition matches the
expected behaviour of movement authorities given above.
\begin{small}
\begin{hetcasl}
\> \Ax{\bullet} \=\Ax{\forall} \Id{ma1} \Ax{:} \IdApplLabel{\Id{MA}}{MA}; \Id{t} \Ax{:} \Id{Time} \\
\>\> \Ax{\bullet} \=\Ax{\neg} \=\Id{ma1} \Ax{=} \=\Ax{[}\Ax{]} 
 \Ax{\Rightarrow} \=\IdApplLabel{\Id{assigned}}{assigned}(\=\Id{ma1}, \IdApplLabel{\Id{suc}}{suc}(\Id{t})) \\
\>\>\>\> \Ax{\Rightarrow} \=(\=\IdApplLabel{\Id{assigned}}{assigned}(\=\Id{ma1}, \Id{t}) \Ax{\wedge} \Ax{\neg} \IdApplLabel{\Id{canExtend}}{canExtend}(\=\Id{ma1}, \Id{t}) \Ax{\wedge} \Ax{\neg} \IdApplLabel{\Id{canReduce}}{canReduce}(\=\Id{ma1}, \Id{t})) \\
\>\>\>\>\> \Ax{\vee} (\=\Ax{\neg} \IdApplLabel{\Id{assigned}}{assigned}(\=\Id{ma1}, \Id{t}) \Ax{\wedge} \IdApplLabel{\Id{canExtend}}{canExtend}(\=\Id{ma1}, \Id{t}) \Ax{\wedge} \Ax{\neg} \IdApplLabel{\Id{canReduce}}{canReduce}(\=\Id{ma1}, \Id{t})) \\
\>\>\>\>\> \Ax{\vee} (\=\Ax{\neg} \IdApplLabel{\Id{assigned}}{assigned}(\=\Id{ma1}, \Id{t}) \Ax{\wedge} \Ax{\neg} \IdApplLabel{\Id{canExtend}}{canExtend}(\=\Id{ma1}, \Id{t}) \Ax{\wedge} \IdApplLabel{\Id{canReduce}}{canReduce}(\=\Id{ma1}, \Id{t}))\\
\`{\small{}\KW{\%}(assigned\_defn)\KW{\%}}
\end{hetcasl}
\end{small}
\noindent The predicate \IdDeclLabel{\Id{canExtend}}{canExtend} \Ax{:}
\IdApplLabel{\Id{MA}}{MA} \Ax{\times} \Id{Time} is true for a given
movement authority $ma2$, at a time $t$, when the following conditions
are met: (1) there exists a movement authority $ma1$ and a route $r$
such that the movement authority $ma1$ is assigned at $t$ and can be
extended to $ma2$ by route $r$. Here, the topological information of
valid extensions from the track plan are encoded using the predicate
\IdDeclLabel{\Id{ext}}{ext} \Ax{:} \IdApplLabel{\Id{MA}}{MA}
\Ax{\times} \IdApplLabel{\Id{Route}}{Route} \Ax{\times}
\IdApplLabel{\Id{MA}}{MA}. We control the behaviour of this predicate
by adding the following axiom:
\begin{small}
\begin{hetcasl}
\> \Ax{\bullet} \=\IdApplLabel{\Id{ext}}{ext}(\=\Id{ma1}, \Id{r}, \Id{ma2}) \Ax{\Rightarrow} \=\Id{ma2} \Ax{=} \=\Id{ma1} \Ax{++} \IdApplLabel{\Id{regions}}{regions}(\Id{r})  \`{\small{}\KW{\%}(\HetsLabel{ext\Ax{\_}defn}{ext\_defn})\KW{\%}}
\end{hetcasl}
\end{small}
\noindent stating that \IdDeclLabel{\Id{ext}}{ext} behaves like list
concatenation. (2) The route used for the extension is open at the
given time -- where the predicate
\Ax{\_\_}\IdDeclLabel{\Id{isOpenAt}}{::isOpenAt::}\Ax{\_\_} \Ax{:}
\IdApplLabel{\Id{Unit}}{Unit} \Ax{\times} \Id{Time} is used (as we
shall see later in Section~\ref{modelling_control_table}) to encode
the clear table conditions of a route; (3) If the movement authority
that is being extended is non empty\footnote{This check is required as
  we want the empty movement authority to always be assigned.}, it
becomes not assigned. This is encoded in \CASL as:
\begin{small}
\begin{hetcasl}
\> \Ax{\forall} \Id{ma1} \Ax{:} \IdApplLabel{\Id{MA}}{MA}; \=\Id{t} \Ax{:} \Id{Time} \\
\> \Ax{\bullet} \=\IdApplLabel{\Id{canExtend}}{canExtend}(\=\Id{ma1}, \Id{t}) \\
\>\> \Ax{\Leftrightarrow} \=\Ax{\exists} \Id{ma2} \Ax{:} \IdApplLabel{\Id{MA}}{MA}; \Id{r} \Ax{:} \IdApplLabel{\Id{Route}}{Route} \\
\>\>\> \Ax{\bullet} \=\IdApplLabel{\Id{assigned}}{assigned}(\=\Id{ma2}, \Id{t})  \Ax{\wedge}  \IdApplLabel{\Id{ext}}{ext}(\=\Id{ma2}, \Id{r}, \Id{ma1}) \\
\>\>\>\> \Ax{\wedge} \=\Id{r} \IdApplLabel{\Id{isOpenAt}}{::isOpenAt::} \Id{t}
 \Ax{\wedge} (\=\Ax{\neg} \=\Id{ma2} \Ax{=} \=\Ax{[}\Ax{]} \Ax{\Rightarrow} \Ax{\neg} \IdApplLabel{\Id{assigned}}{assigned}(\=\Id{ma2}, \IdApplLabel{\Id{suc}}{suc}(\Id{t}))) \`{\small{}\KW{\%}(extends\_defn)\KW{\%}}
\end{hetcasl}
\end{small}
In a similar manner, the predicate
\IdDeclLabel{\Id{canReduce}}{canReduce} \Ax{:}
\IdApplLabel{\Id{MA}}{MA} \Ax{\times} \Id{Time} is true at a given
time $t$ for a given movement authority $ma1$ if there exists a region
$rg$ such that the movement authority with the region in front of
$ma1$ was assigned at $t$ and becomes unassigned at $suc(t)$.
\begin{small}
\begin{hetcasl}
\> \Ax{\forall} \Id{ma1} \Ax{:} \IdApplLabel{\Id{MA}}{MA}; \=\Id{t} \Ax{:} \Id{Time} \\
\> \Ax{\bullet} \=\IdApplLabel{\Id{canReduce}}{canReduce}(\=\Id{ma1}, \Id{t}) \\
\>\> \Ax{\Leftrightarrow} \=\Ax{\exists} \Id{rg} \Ax{:} \IdApplLabel{\Id{Region}}{Region} \\
\>\>\> \Ax{\bullet} \=\IdApplLabel{\Id{assigned}}{assigned}(\=(\=\Id{rg} \Ax{::} \Id{ma1}) \Id{as} \IdApplLabel{\Id{MA}}{MA}, \Id{t}) \Ax{\wedge} \Ax{\neg} \IdApplLabel{\Id{assigned}}{assigned}(\=(\=\Id{rg} \Ax{::} \Id{ma1}) \Id{as} \IdApplLabel{\Id{MA}}{MA}, \IdApplLabel{\Id{suc}}{suc}(\Id{t})) \`{\small{}\KW{\%}(reduces\_defn)\KW{\%}}
\end{hetcasl}
\end{small}

Finally, we would like to ensure that only one movement authority can
be extended at any given time, this is captured using the following
axiom:
\begin{small}
\begin{hetcasl}
\> \Ax{\bullet} \=\Ax{\forall} \Id{t} \Ax{:} \Id{Time} \\
\>\> \Ax{\bullet} \=\Ax{\forall} \Id{m1}, \Id{m2} \Ax{:} \IdApplLabel{\Id{MA}}{MA} \\
\>\>\> \Ax{\bullet} \=(\=\IdApplLabel{\Id{assigned}}{assigned}(\=\Id{m1}, \IdApplLabel{\Id{suc}}{suc}(\Id{t})) 
 \Ax{\Rightarrow} \IdApplLabel{\Id{canExtend}}{canExtend}(\=\Id{m1}, \Id{t})) \Ax{\wedge}\\
\>\>\>\>\> (\=\IdApplLabel{\Id{assigned}}{assigned}(\=\Id{m2}, \IdApplLabel{\Id{suc}}{suc}(\Id{t})) \Ax{\Rightarrow} \IdApplLabel{\Id{canExtend}}{canExtend}(\=\Id{m2}, \Id{t})) \\
\>\>\>\> \Ax{\Rightarrow} \=\Id{m1} \Ax{=} \Id{m2}\`{\small{}\KW{\%}(one\_MA\_changes)\KW{\%}}
\end{hetcasl}
\end{small}
%
\noindent
This assumption is justified by the fact that the Invensys railway
control systems, which are responsible for one rail node, handle at
most one route request at a given time.

\subsubsection{Modelling Control Tables and Route Availability}
\label{modelling_control_table}
The above modelling of movement authorities requires the definition of
what it means for a route to be open. As we have seen, this
information is given by the control table. To model a control table,
we introduce the predicate \IdDeclLabel{\Id{clear}}{clear}~\Ax{:}
\IdApplLabel{\Id{Route}}{Route} \Ax{\times}
\IdApplLabel{\Id{Unit}}{Unit}. We then use this predicate to encode
that a particular unit occurs within the clear column for the given
route. The control table given in Figure~\ref{fig:trackplan} would be
encoded as:
\begin{small}
\begin{hetcasl}
\> \Ax{\bullet} \IdApplLabel{\Id{clear}}{clear}(\=\IdApplLabel{\Id{RX1}}{RX1}, \IdApplLabel{\Id{LA1}}{LA1})\\
\> \Ax{\bullet} \IdApplLabel{\Id{clear}}{clear}(\=\IdApplLabel{\Id{RX1}}{RX1}, \IdApplLabel{\Id{P1}}{P1})\\
\> \dots \\
\> \Ax{\bullet} \IdApplLabel{\Id{clear}}{clear}(\=\IdApplLabel{\Id{RX2}}{RX2}, \IdApplLabel{\Id{LA2}}{LA2})
\end{hetcasl}
\end{small}
\noindent In a similar manner, we could use predicates to encode the
normal and reverse columns of the control table. 
%
%Here, we refrain from this as the direction in which points are set
%can be statically checked according to the topological routes.
%
This would be a straight-forward extension of our railway
model. However, we we refrain from this as we use the railway domain
only as a proof of concept. Therefore, we assume from now on that the
normal and reverse columns in the control table are correct.
Consequently, we exclude their definitions in our modelling. Using the
above described predicates we give the following definition of what it
means for a route to be open:
\begin{small}
\begin{hetcasl}
\>  \=\Ax{\forall} \Id{r} \Ax{:} \IdApplLabel{\Id{Route}}{Route};
  \=\Id{t} \Ax{:} \Id{Time}   \Ax{\bullet} \=\Id{r} \IdApplLabel{\Id{isOpenAt}}{::isOpenAt::} \Id{t} \Ax{\Leftrightarrow} \=\Ax{\forall} \Id{u} \Ax{:} \IdApplLabel{\Id{Unit}}{Unit} \Ax{\bullet} \=\IdApplLabel{\Id{clear}}{clear}(\=\Id{r}, \Id{u}) \Ax{\Rightarrow} \=\Id{u} \IdApplLabel{\Id{isOpenAt}}{::isOpenAt::} \Id{t}
\end{hetcasl}
\end{small}
\noindent This axiom states that a route $r$ is open at a given time
$t$ if for all units $u$ for which clear($r,u$) holds, the unit $u$ is
open at $t$.

Finally, we have yet to consider what is means for a unit to be
occupied. Within the operation of an interlocking a unit is in use
when a train is detected on a particular track. In our modelling, we
abstract on the concrete position of a train and instead say that if a
region is assigned to some train, then we assume that the interlocking
knows that the region is assigned. We model this by saying that one of
the units of the region is not open for use. This is captured by the
following axiom:
\begin{small}
\begin{hetcasl}
\> \Ax{\bullet} \=\Ax{\forall} \Id{t} \Ax{:} \Id{Time}; \Id{r} \Ax{:} \Id{Route}; \Id{rg} \Ax{:} \IdApplLabel{\Id{Region}}{Region}; \Id{ma} \Ax{:} \Id{MA} \\
\>\> \Ax{\bullet}  \IdApplLabel{\Id{assigned}}{assigned}(\=\Id{ma}, \Id{t}) \Ax{\wedge} \=\Id{rg} \IdApplLabel{\Id{eps}}{::eps::} \IdApplLabel{\Id{regions}}{regions}(\Id{r}) \Ax{\wedge} \=\Id{rg} \IdApplLabel{\Id{eps}}{::eps::} \Id{ma}\\
\>\> \Ax{\Rightarrow} \=\Ax{\exists} \Id{u} \Ax{:} \IdApplLabel{\Id{Unit}}{Unit}; \Id{upp} \Ax{:} \IdApplLabel{\Id{UnitPathPair}}{UnitPathPair} \\
\>\>\> \Ax{\bullet}  \Ax{\neg} \=\Id{u} \IdApplLabel{\Id{isOpenAt}}{::isOpenAt::} \Id{t} \Ax{\wedge} \=\Id{u} \IdApplLabel{\Id{eps}}{::eps::} \Id{rg} \Ax{\wedge} \=\Id{getUnit}(\Id{upp}) \Ax{=} \Id{u} \Ax{\wedge} \=\Id{upp} \IdApplLabel{\Id{eps}}{::eps::} \Id{r} 
\`{\small{}\KW{\%}(occupied)\KW{\%}}
\end{hetcasl}
\end{small}
\noindent This axiom makes use of the operation
\IdDeclLabel{\Id{regions}}{regions} \Ax{:}
\IdApplLabel{\Id{Route}}{Route} \Ax{\rightarrow}
\IdApplLabel{\Id{MA}}{MA} that, for a given route gives the regions it
has been split into via our modelling. It also make use of the
operation \IdApplLabel{\Id{eps}}{::eps::} that simply stands for
elementhood. That is, it captures that region $r$ ``is in'' movement
authority $ma$. Overall, the axiom links the assignment of a movement
authority to the openness of a units within the movement
authority. Although this axiom is fairly loose, i.e. we do not even
impose the restriction that trains should move in the correct
direction, this is enough to prove the safety property we discuss
next.

\subsubsection{Modelling our Safety Property}
In Section~\ref{sec:safety_discussion} we discussed the safety
property that we would like to verify. To model such a property, we
introduce the auxiliary predicate \IdDeclLabel{\Id{share}}{share}
\Ax{:} \Id{MA} \Ax{\times} \Id{MA} that encodes what it means for two
movement authorities to overlap:
\begin{small}
\begin{hetcasl}
\PRED \=\IdDeclLabel{\Id{share}}{share} \Ax{:} \=\Id{MA} \Ax{\times} \Id{MA}\\
\> \Ax{\forall} \Id{ma1}, \Id{ma2} \Ax{:} \Id{MA} \\
\>\> \Ax{\bullet} \=\IdApplLabel{\Id{share}}{share}(\=\Id{ma1}, \Id{ma2}) \Ax{\Leftrightarrow} \=\Ax{\exists} \Id{rg} \Ax{:} \IdApplLabel{\Id{Region}}{Region} \Ax{\bullet} \=\Id{rg} \IdApplLabel{\Id{eps}}{::eps::} \Id{ma1} \Ax{\wedge} \=\Id{rg} \IdApplLabel{\Id{eps}}{::eps::} \Id{ma2}
\`{\small{}\KW{\%}(share\_defn)\KW{\%}}
\end{hetcasl}
\end{small}
\noindent This allows us to model safety using the following formula:
\begin{small}
\begin{hetcasl}
\=\Ax{\forall} \Id{t} \Ax{:} \Id{Time}, \Id{ma1}, \Id{ma2} \Ax{:} \Id{MA} \\
\>\> \Ax{\bullet} \=\IdApplLabel{\Id{share}}{share}(\=\Id{ma1}, \Id{ma2}) \\
\>\> \Ax{\Rightarrow} \=\Id{ma1} \Ax{=} \Id{ma2} \Ax{\vee} \Ax{\neg} (\=\IdApplLabel{\Id{assigned}}{assigned}(\=\Id{ma1}, \IdApplLabel{\Ax{t}}{t}) \Ax{\wedge} \IdApplLabel{\Id{assigned}}{assigned}(\=\Id{ma2}, \IdApplLabel{\Ax{t}}{t})) \`{\small{}\KW{\%}(safety)\KW{\%}}
\end{hetcasl}
\end{small}
\noindent It states that if two movement authorities share a region,
then either they are the same, or they are never both assigned at the
same time. This concludes our modelling for movement authorities and
safety, next we consider supporting verification of such a property.








%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
