4 Related Work
Rank polymorphism originally appeared in APL (Iverson, 196 2), which Iverson designed
as a form of mathematical notation, with the APL interpreter serving to eliminate the se-
mantic ambiguity found in conventional notation (Iverson, 1980). At ﬁrst, APL only lifted
scalar functions to operate on aggregate data via pointwise applic ation, either on a scalar
argument and an aggregate argument or on two aggregates of id entical shape. Subsequent
development introduced the notion of function rank, the num ber of dimensions a function
expects its argument to have. This generalized the scalar fu nction lifting, e.g., allowing a
vector-mean function to produce a vector of results when giv en a matrix argument, and
it introduced the “frame of cells” view of aggregate argumen ts where pointwise lifting
generalizes to cellwise lifting. The next generalization s tep was to loosen the rule on frame
shape compatibility. In J (Jsoftware, Inc., n.d.), which Iv erson created as a successor to
APL, a function can be applied to two arguments of differing f rames as long as one frame—
viewed as a sequence of dimensions—is a preﬁx of the other. Th is was a conscious design
--- Page 32 ---
ZU064-05-FPR paper 2 July 2019 1:24
32 Justin Slepak, Olin Shivers and Panagiotis Manolios
decision on Iverson’s part: preﬁx agreement was chosen over sufﬁx agreement because it
ﬁt better with APL’s emphasis on operating along arrays’ maj or axes (Hui, 1995).
FISh also made implicit aggregate lifting part of the semant ics of function application,
and its static semantics resolves the shapes of all arrays (J ay, 1998). A conventional type
judgment describes the elements of arrays computed by a FISh program, and a second
judgment ascribes a shape to each array. In FISh’s metatheor y, the shape of a function is
a function on shapes. Thus a function application’s shape ca n be calculated statically by
applying the shape function to the arguments’ shapes.
As elegant as this model is in a ﬁrst-order language, it is inc ompatible with ﬁrst-class
functions. When functions appear in arrays which are themse lves applied to arguments,
the shape must describe the layout of of that collection of fu nctions, not just the functions’
own behavior. In Remora, a function which checks whether a po int inR3is near the
origin might have the type (-> ((Arr Float (Shp 3))) (Arr Bool (Shp))) . FISh
considers this function’s shape to be the function on a singl eton domain (containing only
[3]) which returns the empty vector. However, Remora expressio ns produce array data,
even in function position. A function array near-origin? containing only that function
has its own “ﬁrst-order” shape (Shp) , independent of any function on shapes summarizing
its behavior.
In resolving all shapes statically, FISh is also too restric tive to permit shapes determined
from run-time data. Functions like iota andfilter cannot exist, nor can the ragged
data which would result from lifting them. By characterizin g functions with restricted
dependent types, Remora escapes both of these limitations.
ZPL is a data-parallel language which was designed to live wi thin a larger language with
a more general parallelism mode (Lin & Snyder, 1994). Its pro gramming model is based on
an explicit map operation over programmer-speciﬁed index s pace within an array. Several
built-in operators modify an index space, such as shifting a section along some dimension,
adding a new dimension by broadcasting, or slicing out a part icular sub-array. The set
of built in operators is constructed to make communication c ost implications clear to the
programmer (Chamberlain et al. , 1998).
NESL uses a nested-vector data model, rather than the rank-p olymorphic regular-array
model (Blelloch, 1995). Programs map operations over vecto rs using a comprehension
notation. Since a vector’s elements may themselves be vecto rs with widely varying lengths,
NESL’s main performance trick is turning irregular nested v ectors into a ﬂat internal rep-
resentation. After ﬂattening, NESL can evenly distribute t he computation workload by
splitting at places that user code doe not consider not sub-v ector boundaries.
The goal of isolating the cell-level portion of a program has also led to some domain-
speciﬁc languages, targeting speciﬁc varieties of regular aggregate data. Halide is a lan-
guage designed for writing image processing pipelines (Rag an-Kelley et al. , 2012). The
iteration space is the set of pixels in an image. A Halide prog rammer writes code describing
how an individual pixel should be handled (or a cluster of pix els for stencil computation),
and then in a separate portion of the program, the programmer describes how the iteration
space ought to be traversed. Since the program does not inter mingle loop-nest control code
with loop-body computation code, it is easier for a maintain er to tune for performance by
adjusting the iteration schedule.
--- Page 33 ---
ZU064-05-FPR paper 2 July 2019 1:24
The Semantic Foundations of Rank Polymorphism 33
Diderot is a programming language speciﬁcally aimed at proc essing medical images
(Chiw et al. , 2012). The universe of data consists of tensor ﬁelds, inten ded as functions
on the continuous domain Rn, rather than any particular discrete index space. Diderot
offers pointwise arithmetic on tensors and a collection of c ommon operations such as outer
product and transposition. Aggregate lifting appears agai n, albeit in a smaller form, with
some operations on tensor ﬁelds.
HorseIR uses implicit lifting over arrays as an intermediat e representation for SQL
queries (Chen et al. , 2018). HorseIR is lower-level than APL itself, serving as a three-
address IR with vector instructions, and the IR itself is des igned to ease loop fusion. In
contrast with APL, all HorseIR arrays are vectors—there are no higher-rank arrays, and
scalars are represented as unit-length vectors. There is al so a list datatype for handling
heterogeneous aggregate data, such as one row of a database t able.
Our type system’s use of restricted dependent types is inspi red by Dependent ML (Xi, 1998).
While Dependent ML is designed with the expectation that the index language has a fully
decidable theory, Remora’s index language does not (Durnev , 1995). In subsequent work,
Dependent ML also focused on ensuring safety of array index a ccesses, using single-
ton and range types to ensure that numbers used for indexing f ell within arrays’ bounds
(Xi & Pfenning, 1998).
Others have applied established type system machinery to an APL-like computation
model. Thatte’s coercion semantics (Thatte, 1991) uses a fo rm subtyping in which scalar
types are subtypes of aggregates, and aggregate types in cer tain situations are subtypes of
higher-dimensional aggregates. The subtyping rules emit c oercions which invoke functions
such asmap andreplicate , automatically adapting scalar functions to aggregate dat a.
However, the restrictions on treating aggregate types as su btypes of larger aggregates
prohibit lifting for functions which expect non-scalar inp ut (i.e., those whose expected
rank is greater than zero) and lifting to unequal frame shape s (e.g., vector-matrix addition).
Gibbons’s embedding of in an extended Haskell (Gibbons, 201 6) extensively uses type-
level programming and deﬁnes much of the rank-polymorphic l ifting machinery in terms
of transposition.
Single Assignment C (SAC) is a variant of C without mutation ( Scholz, 2003). The
primary iteration mechanism in SAC is the with loop, in which the programmer de-
scribes a traversal of the index space and builds an output ar ray an element at a time.
The lack of mutation pushes the programmer to avoid writing l oop-carried dependence,
much like in the rank-polymorphic model. Translation of wel l-behaved APL programs
to SAC tends to be straightforward (Grelck & Scholz, 1998), t hough the resulting loop
structure is somewhat speciﬁc to the function being lifted. A SAC variant called Qube
introduces a Dependent ML-style type system to ensure the sa fety of indexed array element
accesses (Trojahner & Grelck, 2009). Qube retains SAC’s with loop-based programming
model—relying on range types in contrast to APL’s and Remora ’s implicitly lifted function
application semantics—and due to its C roots, it does not sup port ﬁrst-class functions to
the extent of permitting arrays to appear in function positi on.
Since the syntactic structure of a line of APL code, in partic ular the meaning of the
juxtaposition of two terms, depends on the meanings of names which appear in the code,
standard APL does not admit a fully static parsing algorithm . Due to this and other idiosyn-
--- Page 34 ---
ZU064-05-FPR paper 2 July 2019 1:24
34 Justin Slepak, Olin Shivers and Panagiotis Manolios
cratic warts, past efforts to compile APL have typically tar getted large but well-behaved
subsets of the language.
A prominent exception is the APL\3000 compiler, which could produce machine code
for individual statements and used interpretation to manag e inter-statement control ﬂow
(Johnston, 1979). This allowed some intraprocedural optim ization, such as fold-unfold
and map-map fusion3(Abrams, 1970), analogous to deforestation which arose in m ain-
stream functional languages (Burstall & Darlington, 1977; Wadler, 1984). It also ensured
that names’ dynamic meanings would be available by the time e xecution reached any
statement which used them.
Weiss and Saal instead applied interprocedural data-ﬂow an alysis to resolve the syntactic
classes of variable names in APL code (Weiss & Saal, 1981). Th is analysis is not complete
for APL itself due to the possibility that reassignment of a v ariable name will change how
some line of code parses. However, the authors found that rea l-world code did not make use
of the full freedom to manipulate the syntactic structure of an APL program by dynamically
reassigning variables, suggesting that this is a misfeatur e which can be discarded for little
cost. However, the common line-at-a-time compilation styl e used in other work also served
to ensure that by the time execution reaches a line of code, it s variable names, and thus their
syntactic classes, could be resolved.
Budd describes a compiler for an APL variant in which the ambi guity in parsing is
avoided by declaring identiﬁers before use and name resolut ion is simpliﬁed by adopting
lexical scope. (Budd, 1988).
APEX parallelizes an APL dialect with restrictions on many A PL features deemed
incompatible with compilation (such as producing a string r epresentation of an arbitrary
function) or not strictly necessary for practical use (such asGOTO ) (Bernecky, 1999). APEX’s
shape compatibility rules for implicit aggregate lifting a re less permissive than APL, e.g.,
prohibiting most cases of vector-matrix addition. Instead , both arguments must have the
same rank or at least one argument passed to a scalar-consumi ng function be a scalar or
singleton vector.
A more recent line of work has focused on intermediate repres entations of array pro-
grams, such as the Typed Array Intermediate Language, which makes aggregate opera-
tions explicit using an each primitive operator (Elsman & Dybdal, 2014). The type system
tracks arrays’ ranks, which provides enough information to recognize when an each call
is needed, but it is not meant to ensure that lifting a functio n application has a well-
deﬁned result ( i.e., shape incompatibility is still possible). L0plots out a loop fusion
strategy inspired by control ﬂow graph reduction (Henrikse n & Oancea, 2013). The L0
compiler splits array programs into kernels of fused aggreg ate operations based on the
applicability of T2graph reductions (merging nodes XandYifXisY’s sole predecessor)
to the program’s data ﬂow graph.
3In the APL community, these transformations are respective ly referred to as “beating” (imagine a
metronome producing a stream of beats) and “dragging along” (amassing a chain of delayed scalar
operations to apply in a single loop body).
--- Page 35 ---
ZU064-05-FPR paper 2 July 2019 1:24
The Semantic Foundations of Rank Polymorphism 35
5 Conclusion
While APL and its descendant languages have attracted a devo ted userbase, there has been
little cross talk between the array-language community and the broader programming
language research community. Much of the analysis opportun ity taken for granted by
lambda calculists has been unavailable in APL—despite the m any implementations, such
languages lacked formal semantics amenable to proofs. Mean while, implementations of
rank-polymorphic languages have struggled with compilati on due to control structure that
is “too dynamic,” depending on run-time data to determine th e structure of a loop nest.
Developing Remora’s semantics kills two birds with one ston e: Formally stated reduc-
tion rules describe the results expected from the implicit, data-driven control structure, and
typing rules give enough information about array shapes to i dentify that control structure
statically. This necessarily entails recognizing program s which cannot have such a control
structure due to incompatible array shapes—this is not what we set out to do but a beneﬁt
realized by pursuing a larger goal. By casting the aggregate lifting as an extension to λ-
calculus’s function application semantics, we escape from APL’s limitation on function
arity and can treat functions as ﬁrst-class values.
There are two things to look for in evaluating a type system. W e want to know the
conclusions drawn by type checking reﬂect reality, which is handled by a conventional
type soundness theorem. We also want to be sure that the types convey the information we
seek. In Remora’s case, that information is the iteration st ructure implicit in each function
application. The typing rule for function application (and similarly, the rules for type and
index application) produces a static characterization of t hat implicit iteration structure.
Our type erasure can be seen as a compilation pass which moves the decision about how
to break arguments into cells from the function’s type into t he application term. While our
primary purpose in presenting type erasure is to point out ty pe-level information which
is not truly needed at run time, it also serves to make the cont rol structure one step more
explicit. Arguments’ full shapes—available both at erasur e time and later by inspecting
argument terms—sufﬁce to determine the arguments’ frames, the last puzzle piece needed
to turn Remora’s implicit iteration structure into explici t calls to map andreplicate
functions. Our intention for future work is to demonstrate u se of that shape information
for fully static compilation of Remora code.
References
Abrams, Philip S. (1975). What’s wrong with APL? Pages 1–8 of: Proceedings of Seventh
International Conference on APL . APL ’75. New York, NY , USA: ACM.
Abrams, Philip Samuel. (1970). An apl machine . Ph.D. thesis, Stanford, CA, USA. AAI7022146.
Backus, John. (1978). Can programming be liberated from the V on Neumann style?: A functional
style and its algebra of programs. Commun. ACM ,21(8), 613–641.
Bernecky, Robert. (1999). APEX, the APL parallel executor . M.Phil. thesis, National Library of
Canada= Bibliothèque nationale du Canada.
Blelloch, Guy. (1995). NESL: A nested data-parallel language (version 3.1) . Tech. rept.
Budd, Timothy. (1988). An APL compiler . Springer-Verlag.
Burstall, R. M., & Darlington, John. (1977). A transformati on system for developing recursive
programs. J. acm ,24(1), 44–67.
--- Page 36 ---
ZU064-05-FPR paper 2 July 2019 1:24
36 Justin Slepak, Olin Shivers and Panagiotis Manolios
Chamberlain, B., Choi, S., Lewis, E., Lin, C., Snyder, L., & W eathersby, W. (1998). ZPL’s
WYSIWYG performance model. Pages 50– of: Proceedings of the High-Level Parallel
Programming Models and Supportive Environments . HIPS ’98. Washington, DC, USA: IEEE
Computer Society.
Chen, Hanfeng, D&#39;silva, Joseph Vinish, Chen, Hongji, K emme, Bettina, & Hendren, Laurie.
(2018). Horseir: Bringing array programming languages tog ether with database query processing.
Pages 37–49 of: Proceedings of the 14th ACM SIGPLAN Internat ional Symposium on Dynamic
Languages . DLS 2018. New York, NY , USA: ACM.
Chiw, Charisee, Kindlmann, Gordon, Reppy, John, Samuels, L amont, & Seltzer, Nick. (2012).
Diderot: A parallel DSL for image analysis and visualizatio n.Pages 111–120 of: Proceedings
of the 33rd ACM SIGPLAN Conference on Programming Language D esign and Implementation .
PLDI ’12. New York, NY , USA: ACM.
Durnev, Valery G. (1995). Undecidability of the positive ∀∃3-theory of a free semigroup. Siberian
mathematical journal ,36(5), 917–929.
Elsman, Martin, & Dybdal, Martin. (2014). Compiling a subse t of APL into a typed intermediate
language. Pages 101:101–101:106 of: Proceedings of ACM SIGPLAN Inter national Workshop on
Libraries, Languages, and Compilers for Array Programming . ARRAY’14. New York, NY , USA:
ACM.
Gibbons, Jeremy. (2016). APLicative programming with nape rian functors (extended abstract).
Pages 13–14 of: Proceedings of the 1st International Worksh op on Type-Driven Development .
TyDe 2016. New York, NY , USA: ACM.
Grelck, Clemens, & Scholz, Sven-Bodo. (1998). Acceleratin g APL programs with SAC. vol. 29.
New York, NY , USA: ACM.
Henriksen, Troels, & Oancea, Cosmin Eugen. (2013). A t2 grap h-reduction approach to fusion. Pages
47–58 of: Proceedings of the 2Nd ACM SIGPLAN Workshop on Func tional High-performance
Computing . FHPC ’13. New York, NY , USA: ACM.
Hui, Roger K. W. (1995). Rank and uniformity. SIGAPL APL quote quad ,25(4), 83–90.
Iverson, Kenneth E. (1962). A programming language . New York, NY , USA: John Wiley & Sons,
Inc.
Iverson, Kenneth E. (1980). Notation as a tool of thought. Commun. ACM ,23(8), 444–465.
Jay, C. B. (1998). The FISh language deﬁnition . Tech. rept.
Johnston, Ronald L. (1979). The dynamic incremental compil er of APL\3000. Pages 82–87 of:
Proceedings of the International Conference on APL: Part 1 . APL ’79. New York, NY , USA:
ACM.
Jsoftware, Inc. Jsoftware: High-performance development platform .
Lin, Calvin, & Snyder, Lawrence. (1994). ZPL: An array subla nguage. Pages 96–114 of: Proceedings
of the 6th International Workshop on Languages and Compiler s for Parallel Computing . London,
UK, UK: Springer-Verlag.
Mathworks, Inc. (1992). Matlab, user’s guide . Natick, MA.
Oliphant, Travis E. 2006 (12). Guide to numpy . Trelgol Publishing USA.
Ragan-Kelley, Jonathan, Adams, Andrew, Paris, Sylvain, Le voy, Marc, Amarasinghe, Saman, &
Durand, Frédo. (2012). Decoupling algorithms from schedul es for easy optimization of image
processing pipelines. Acm trans. graph. ,31(4), 32:1–32:12.
Scholz, Sven-Bodo. (2003). Single assignment C: efﬁcient s upport for high-level array operations in
a functional setting. J. funct. program. ,13(6), 1005–1059.
Thatte, Satish. (1991). A type system for implicit scaling. Sci. comput. program. ,17(1-3), 217–245.
Trojahner, Kai, & Grelck, Clemens. (2009). Dependently typ ed array programs don’t go wrong.
Journal of logic and algebraic programming ,78(7), 643–664.
--- Page 37 ---
ZU064-05-FPR paper 2 July 2019 1:24
The Semantic Foundations of Rank Polymorphism 37
Wadler, Philip. (1984). Listlessness is better than lazine ss: Lazy evaluation and garbage collection at
compile-time. Pages 45–52 of: Proceedings of the 1984 ACM Symposium on LISP and Functional
Programming . LFP ’84. New York, NY , USA: ACM.
Weiss, Zvi, & Saal, Harry J. (1981). Compile time syntax anal ysis of APL programs. Pages 313–320
of: Proceedings of the International Conference on APL . APL ’81. New York, NY , USA: ACM.
Xi, Hongwei. (1998). Dependent types in practical programming . Ph.D. thesis, Pittsburgh, PA, USA.
AAI9918624.
Xi, Hongwei, & Pfenning, Frank. (1998). Eliminating array b ound checking through dependent
types. Pages 249–257 of: Proceedings of the ACM SIGPLAN 1998 Confer ence on Programming
Language Design and Implementation . PLDI ’98. New York, NY , USA: ACM.