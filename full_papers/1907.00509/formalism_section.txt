2 Formalism
We present a formal description of Core Remora, which descri bes the control-ﬂow mech-
anism used for computing on arrays. While the nested-vector shorthand used earlier is
convenient for human use, this formalism explicitly distin guishes atoms from arrays.
The basic design goal for the language of types and indices is to describe the program’s
control structure, for a compiler’s beneﬁt. This requires a detailed description of array
shapes. Knowing only the number of axes an array has is insufﬁ cient because good map-
ping from source to hardware— e.g., whether to emit vector instructions, invoke a GPGPU
kernel, or fork separate parallel threads—depends more on t he actual sizes of individual
axes than on how many there are. We use indexed types, in the st yle of Dependent ML:
rather than allowing types to be parameterized over arbitra ry terms, they are parameter-
ized over a limited language of type indices. Remora’s index language consists of natural
numbers, representing individual dimensions, and sequenc es of naturals, representing array
shapes (or fragments of shapes). So the type of an array has th e form(Arr τ ι), where
--- Page 4 ---
ZU064-05-FPR paper 2 July 2019 1:24
4 Justin Slepak, Olin Shivers and Panagiotis Manolios
τidentiﬁes the type of the array’s atoms, and ιdescribes the array’s shape. This includes
enough detail for the type system to describe how the functio n and argument arrays align
in function application. It also grants the ability to stati cally detect arrays that cannot be
properly aligned.
Fixed-size computation, requiring every function to exact ly specify its argument and
result sizes, is far too restrictive for practical use. Prog rammers should not have to write a
separatevector-mean function for every possible length of vector their programs might
use. So the index language must permit variables, and the typ e language must allow uni-
versal quantiﬁcation. This is phrased as a dependent produc t:(Pi (( xγ)...)τ). Each
xis marked with its sort γ, which speciﬁes whether xranges over individual dimensions
(γ=Dim) or sequences ( γ=Shape ). Now we can give a type to vector-mean :
(Pi ((n Dim))
(-> ((Arr Float (Shp n)))
(Arr Float (Shp))))
This function will lift to operate on higher-rank arrays of Float s, effectively behaving as
a minor-axis mean function. Having Shape variables in addition to Dim variables allows
us to type a major-axis mean function as well:
(Pi ((c Shape) (n Dim))
(-> ((Arr Float (++ (Shp n) c)))
(Arr Float c)))
Combined with parametric polymorphism, where type variabl es can be quantiﬁed sep-
arately over the kinds Atom andArray , we now have a lot of ﬂexibility in describing a
function’s behavior. For example, append stitches two arrays together along their major
axis. This requires that the (n−1)-dimensional pieces of each n-dimensional array have
the same type ( i.e., they must share the same Atom -kinded type variable), but we must
introduce separate index variables (of sort Dim) for the arguments’ major axes. The type
we give to append is
(Pi ((c Shape) (m Dim) (n Dim))
(Forall ((a Atom))
(-> ((Arr a (++ (Shp m) c))
(Arr a (++ (Shp n) c)))
(Arr a (++ (Shp (+ m n)) c)))))
We have index variables mandnto stand for each argument’s ﬁrst dimension and cto
denote the rest of their shapes. Quantifying over the type va riableaallowsappend to work
independent of the type of atoms its arguments contain. Our r esult type’s ﬁrst dimension is
the sum of the arguments’ ﬁrst dimensions, but it has the same “remainder” shape c.
Quantifying over Array types is a convenience—it is not strictly necessary. Concre te
Array -kinded types must be of the form (Arr τ ι), so polymorphic types of the form
(Forall(( xArray)) τ)could be rewritten with fresh variables xsandxaas
(Pi (( xsShape))
(Forall (( xaAtom))
τ[x/maps⊔o→(Arr xaxs)]))
--- Page 5 ---
ZU064-05-FPR paper 2 July 2019 1:24
The Semantic Foundations of Rank Polymorphism 5
Even having escaped the conﬁnes of ﬁxed-size computation, w e so far only have func-
tions whose result shape depends solely on its arguments’ sh apes. Common utility func-
tions such as iota andfilter have result shapes which depend on the actual run-time data
they receive. We can solve this limitation using existentia l quantiﬁcation. A dependent sum
type,(Sigma (( xγ)...)τ), conceptually represents a tuple containing indices whose
respective sorts are γ...and an array whose type τmay depend on those indices. This is the
type-level description of a box, the atomic wrapper around an arbitrary array. Such types
can encode arrays whose dimensions are not all known. For exa mple,(Sigma ((n Dim))
(Arr Int (Shp n))) can describe any vector of integers without giving its speci ﬁc
length. Note that the type still requires the underlying arr ay to have rank 1. No scalar
or matrix or higher-ranked array can ﬁt the pattern speciﬁed by(ArrInt(Shpn)) , the
dependent sum’s body. Use of dependent sums offers a lot of fr eedom in stating what
shape information is known precisely and what is hidden. At o ne extreme, (Sigma ((s
Shape)) (Arr Int s)) could contain an array of absolutely any shape. We can also
write more detailed descriptions, e.g., ﬂoating-point matrices with exactly three rows and
at least two columns:
(Sigma ((c Dim))
(Arr Float
(Shp 3 (+ 2 c))))
Quantifying over shapes allows us to describe arrays where o nly speciﬁc axes are known,
such as boolean arrays whose leading axis has length 10:
(Sigma ((s Shape))
(Arr Bool
(++ (Shp 10) s)))
Typing boxes as dependent sums also permits controlled acce ss to ragged arrays, which
are typed as arrays of boxes. Consider a vector of 20 strings o f varying lengths:
(Arr (Sigma ((len Dim))
(Arr Char (Shp len)))
(Shp 20))
Any function written to operate on a box of the appropriate ty pe, in this case containing
Char vectors of completely unknown length, can be safely lifted t o operate on this vector
of strings. Separating the lifting over the outer dimension s from the lifting over inner,
existentially hidden dimensions reﬂects an important cons ideration for code generation:
ragged dimensions in a type identify when implicit parallel ism is irregular , in contrast
with the strictly regular parallelism offered in box-free c ode. Raggedness is not restricted
to the minor axis because a box’s type can still specify some e xact dimensions, as in
(Arr (Sigma ((l Dim))
(Arr Char (Shp l 80)))
(Shp 20))
Here we have a vector of 20 documents, each of which is a charac ter array containing an
unknown number of 80-character lines.
--- Page 6 ---
ZU064-05-FPR paper 2 July 2019 1:24
6 Justin Slepak, Olin Shivers and Panagiotis Manolios
e∈Expr ::= Expressions
x Variable reference
|(array( n...)a...) Array, containing atoms
|(array( n...)τ) Empty array, with its atom type
|(frame( n...)e...) Frame, containing array cells
|(frame( n...)e...) Empty frame, with its cell type
|(efea...) Term application
|(t-app eτ...) Type application
|(i-app eι...) Index application
|(unbox( xi...xees)eb) Let-binding box contents
v∈Val::=x|(array( n...)v...) Values
a∈Atom ::= Atoms
b Base value
|o Primitive operator
|(λ((xτ)...)e) Term abstraction
|(Tλ((x k)...)v) Type abstraction
|(Iλ((xγ)...)v) Index abstraction
|(box ι...eτ) Boxed array
v∈Atval ::=b|o|(λ((xτ)...)e)|(Tλ((x k)...)v) Atomic values
|(Iλ((xγ)...)v)|(box ι...vτ)
τ∈Type ::= Types
x Type variable
|B Base type
|(Arr τ ι) Array
|(->( τ...)τ′) Function
|(Forall(( x k)...)τ) Universal
|(Pi(( xγ)...)τ) Dependent product
|(Sigma(( xγ)...)τ) Dependent sum
k∈Kind ::=Array|Atom Kinds
ι∈Idx::= Type indices
x Type variable
|n Single dimension
|(Shp ι...) Sequence of dimensions)
|(+ι...) Adding dimensions
|(++ι...) Appending shapes
γ∈Sort ::=Shape|Dim Index sorts
o∈Op::=+|-|*|/|append|reduce|iota|... Primitive operators
f∈Func ::=o|e Functions
t∈Term ::=a|(λ((xτ)...)e) Terms
Fig. 1. Core Remora grammar
2.1 Syntax
The grammar for Core Remora is given in Figure 1. Term-level s yntax is divided into
atoms, noted as a, and expressions, noted as e. Expressions produce arrays, which contain
atoms. For the most part, atom terms perform only trivial com putation. This rule applies
to base values, noted as b; primitive operators, noted as o; and λ-abstractions, which
may abstract over terms, types, and type indices. As an excep tion, a box gives an atomic
view of an array of any shape and may therefore perform any com putation to compute its
contents. A box hides part of its contents’ shape, using a dep endent sum. It existentially
--- Page 7 ---
ZU064-05-FPR paper 2 July 2019 1:24
The Semantic Foundations of Rank Polymorphism 7
quantiﬁes type indices, but an explicit type annotation is r equired. A box built from the
index3and a 3×3 matrix could be meant, for example, as an unspeciﬁed-lengt h vec-
tor containing 3-vectors, with type (Sigma ((n Dim)) (Arr Int (Shp n 3))) or as
a square matrix of unspeciﬁed size, with type (Sigma ((n Dim)) (Arr Int (Shp n
n)))(Sigma((nDim))(ArrInt(Shpn n))) ;.
An array can be written as a literal, with its shape and indivi dual atoms listed directly. It
can also be written in nested form as a frame containing cells (its subexpressions) arranged
in the speciﬁed shape. For example, the matrix/bracketleftbig1 2
3 4/bracketrightbig
can be written as the literal
(array(2 2)1 2 3 4)
or as a vector frame of vector literal cells:
(frame (2) (array (2) 1 2) (array (2) 3 4))
The frame notation allows construction of arrays from uneva luated cells. An empty array
(i.e., one with a zero in its shape) must be written with the type its elements are meant to
have. An empty vector of integers is a different value than an empty vector of booleans,
and they inhabit different types.
Term, type, and index abstractions can be applied to zero or m ore expressions, types, or
indices. The body of the abstraction must itself be an expres sion, i.e., all functions produce
arrays as their results.
Consuming a box let-binds its index- and term-level content s. Suppose we have M, a
boxed square matrix of unspeciﬁed size. Unboxing Mas in(unbox(laM) e)lets us use
the index variable land term variable awithin e, the body.
Types include base types (noted as B), functions, arrays, universal types, and dependent
products and sums. Universals specify the kind of each type a rgument, and dependent
products and sums specify the sort of each index argument. Ty pes are classiﬁed as either
Atom orArray . Type indices are naturals and sequences of naturals, with a ddition and
appending as the only operators. They are classiﬁed into sor ts,DimandShape .
The grammar in Figure 1 does not require any speciﬁc set of pri mitive operators, base
types, and base values. An example collection of array-mani pulation primitives and their
types is given in Figure 2. For readability, we elide the encl osingPiandForall forms.
Most of these primitives perform some operation along the ar gument’s major axis. For
example,head extracts the ﬁrst scalar of a vector, the ﬁrst row of a matrix, etc.This means
that the argument shape must have one dimension more than the result shape, and that
extra dimension must be nonzero. This is expressed in the typ e ofhead by giving the
argument shape (++ (+ 1 d) s) ,i.e., a single dimension which is 1 plus any arbitrary
natural followed by any arbitrary sequence of naturals. In t aking one scalar from a 3-vector,
we would instantiate das the dimension 2andsas the empty shape (Shp) . If we want to
extract the ﬁrst plane of a 5 ×6×7 array, we use 4fordand(Shp 6 7) fors.
Since these operations work along the major axis, we can use o ther axes instead by
instantiating them differently. Suppose mtxis the matrix (array (3 2) 0 1 2 3 4 5) ,
which has type (Arr Num (Shp 3 2)) . Then(t-app (i-app head 2 (Shp 2)) Num)
is a function which extracts the ﬁrst row of a (1+2)×2 (i.e., 3×2) matrix. So ((t-app
(i-app head 2 (Shp 2)) Num) mtx) evaluates to (array (2) 0 1) . Instead, con-
sider(t-app (i-app head 1 (Shp)) Num) . This is a function with input type (Arr
--- Page 8 ---
ZU064-05-FPR paper 2 July 2019 1:24
8 Justin Slepak, Olin Shivers and Panagiotis Manolios
Num (Shp 2)) and output type (Arr Num (Shp)) . It extracts the ﬁrst scalar of a 2-
vector. When applied to mtx, this function liftsto extract the ﬁrst scalar from each 2-vector,
gathering the results as (frame (3) (array () 0) (array () 2) (array () 4)) .
Evaluation proceeds, reducing this to (array (3) 0 2 4) , the ﬁrst column of mtx.
Several primitives must return boxed arrays because the typ e system cannot keep track of
enough information to fully describe the result shape. As an extreme example, read-nums
reads a vector of numbers from user input, and there is no way o f knowing until run
time how long a vector the user will enter. In other cases, the necessity of boxing comes
from a limit on the type system’s expressive power. The ravel function produces a vector
whose atoms are all those of the argument array, laid out in ro w-major order. The length
of theravel of some array is fully determined by that array’s shape: it is the product
of all of its dimensions. However the undecidability of Pean o arithmetic would interfere
with type checking (not to mention future efforts on type inf erence). Since “product of all
dimensions” is not expressible in Presburger arithmetic, w e instead have ravel return a
boxed vector.
Boxing is not limited to vectors. For example, filter uses a vector of booleans to
decide which parts of an array to retain. Since the number of t rue entries in that vector
is unknown, the size of the result’s major axis is also unknow n. The resulting Sigma
type existentially quantiﬁes only that one dimension, and l eaves the remaining dimensions
externally visible.
Theiota functions and their variants , described in Figure 3, form a u seful case study on
what invariants can be expressed in Remora’s type system. Th ese functions produce arrays
whose atoms are successive natural numbers starting from 0, such as(array (2 3) 0 1
2 3 4 5) , representing the matrix/bracketleftbig0 1 2
3 4 5/bracketrightbig
. The argument to iota is a vector of numbers
specifying the result array’s shape. Since this vector can b e dynamically computed, we
cannot give any speciﬁc shape for iota ’s return type. Instead, iota must return a box
with existentially quantiﬁed shape. Recall that boxing arr ays allows functions with data-
dependent result shape to lift safely, since applying iota to(array (2 2) 3 3 4 4)
must produce a 3 ×3 matrix and a 4 ×4 matrix as its two result cells.
Variants on iota allow the programmer to communicate more detailed knowledg e to
the type system. When the result is meant to be a vector, iota/v takes that vector’s length
as the argument. The resulting box is typed as a vector of unkn own length rather than an
array of completely unknown shape. Knowing that we have a vec tor of numbers rather than
any arbitrary array means, for example, that summing the box ’s contents with reduce is
certain to produce a scalar. We can therefore type the follow ing function as consuming and
producing non-boxed scalar numbers:
(λ((n (Arr Num (Shp))))
(unbox (len nums ((array () iota/v) n))
((t-app (i-app (array () reduce) len (Shp)) Num)
+
((t-app (i-app (array () append) 1 len (Shp)) Num)
(array () 0)
nums))))
--- Page 9 ---
ZU064-05-FPR paper 2 July 2019 1:24
The Semantic Foundations of Rank Polymorphism 9
Function Type
head ,tail (-> ((Arr t (++ (Shp (+ 1 d)) s)))
(Arr t s))
behead ,curtail (-> ((Arr t (++ (Shp (+ 1 d)) s)))
(Arr t (++ (Shp d) s)))
length (-> ((Arr t (++ (Shp d) s)))
(Arr Num (Shp)))
shape ,ravel (-> ((Arr t s))
(Arr (Sigma ((d Dim)) (Arr Num (Shp d)))
(Shp)))
append (-> ((Arr t (++ (Shp m) s))
(Arr t (++ (Shp n) s)))
(Arr t (++ (Shp (+ m n)) s)))
reverse (-> ((Arr t (++ (Shp d) s)))
(Arr t (++ (Shp d) s)))
rotate (-> ((Arr t (++ (Shp d) s))
(Arr Num (Shp)))
(Arr t (++ (Shp d) s)))
fold (-> ((Arr (-> ((Arr t s) T) T) (Shp))
T
(Arr t (++ (Shp d) s)))
T)
reduce (-> ((Arr (-> ((Arr t s) (Arr t s))
(Arr t s))
(Shp))
(Arr t (++ (Shp (+ 1 d)) s)))
(Arr t s))
scan (-> ((Arr (-> ((Arr u r) (Arr t s)) (Arr u r)) (Shp))
(Arr u r)
(Arr t (++ (Shp d) s)))
(Arr u (++ (Shp d) r)))
filter (-> ((Arr Bool d)
(Arr t (++ (Shp d) s)))
(Arr (Sigma ((k Dim)) (Arr t (++ (Shp k) s))) (Shp)))
read-nums (-> () (Arr (Sigma ((k Dim)) (Arr Num (Shp k))) (Shp )))
iota (-> ((Arr Num (Shp d)))
(Arr (Sigma ((s Shape)) (Arr Num s)) (Shp)))
reshape (-> ((Arr Num (Shp d))
(Arr t r))
(Arr (Sigma ((s Shape)) (Arr Num s)) (Shp)))
Fig. 2. Common array-manipulation primitive operations an d their Remora types
--- Page 10 ---
ZU064-05-FPR paper 2 July 2019 1:24
10 Justin Slepak, Olin Shivers and Panagiotis Manolios
Function Type
iota (-> ((Arr Num (Shp d)))
(Arr (Sigma ((s Shape)) (Arr Num s)) (Shp)))
iota/v (-> ((Arr Num (Shp)))
(Arr (Sigma ((d Dim)) (Arr t (Shp d))) (Shp)))
iota/s (Pi ((s Shape))
(-> () (Arr Num s)))
iota/w (-> ((Arr t s))
(Arr Num s))
Fig. 3. Types for iota and its variants
In a more programmer-friendly surface language, with autom atic instantiation of polymor-
phic functions2and conversion of bare atoms to scalar arrays, this might be w ritten as:
(λ((n (Arr Num (Shp))))
(unbox (len nums (iota/v n))
(reduce + (append [0] nums))))
Alternatively, the programmer might prefer to use iota/s to pass the desired result
shape as a type index rather than as a term-level vector. In th at case, there is no need to
box the result array. In the automatic-instantiation short hand,iota/s may be stylistically
awkward, calling for the variant iota/w , which takes an extra array argument as a “shape
witness” rather than instantiating at a shape index. Produc ing a number array whose shape
matches some existing array xscould then be written as (iota/w xs) instead of ((i-app
iota/s shape-of-xs)) .
Thereshape function behaves similarly to iota , except that the atoms in the result
array are drawn from the second argument, repeating them cyc lically if necessary. So
usingreshape with the shape speciﬁcation (array (2) 3 2) and the vector (array
(5) 1 2 3 4 5) produces the 3 ×2 matrix(array (3 2) 1 2 3 4 5 1) . Likeiota ,
reshape beneﬁts from alternative ways for the programmer to specify the result shape.
2.2 Theory of type indices
Type indices, given in program syntax as ι, represent individual dimensions, taken from N,
and array shapes, taken from the free monoid on N. The theory of the free monoid on N
includes as axioms the associativity of adding naturals and appending sequences as well as
unique identity elements for addition (zero) and appending (the scalar shape, /square):
0+i=i+0=i
(i+j)+k=i+(j+k)
/square+ +a=a+ +/square=a
2This inference problem is beyond the scope of this paper.
--- Page 11 ---
ZU064-05-FPR paper 2 July 2019 1:24
The Semantic Foundations of Rank Polymorphism 11
a b
c d
w
Fig. 4. Overlap axiom, visualized: wis the overlapping portion of aandd.
(a+ +b)+ +c=a+ +(b+ +c)
As the free monoid, it also follows an equidivisibility rule which stat es that if two
uses of the append operator give the same result, there is som e completing subsequence,
representing the overlap between each use’s larger argumen t (demonstrated in Figure 4):
a+ +b=c+ +d=⇒ ∃ w.(a+ +w=c∧w+ +d=b)∨(c+ +w=a∧w+ +b=d)
A free monoid (on any set of generators) also has a homomorphi sm to the monoid
formed by Nunder addition, with the property that only the free monoid’ s identity element
can be mapped to 0. This can be axiomatized with one additiona l function symbol L:
L(a)=0=⇒a=/square
L(a+ +b)=L(a)+L(b)
Using equidivisibility and the homomorphism to the additiv eNmonoid, we can deﬁne a
partial operator ·−for preﬁx subtraction: a·−b=ciffb+ +c=a. For example, [3,4,5,6]·−
[3,4]=[5,6], whereas [3,4,5,6]·−[4]is undeﬁned.
Type checking only requires a very restricted fragment of th is theory. Pairs of indices are
only checked for equality in isolation from each other, and n o information about an index
(other than its sort) is given in the program. So the check is f or the validity of a single
equality—no connectives or quantiﬁers needed. This fragme nt can be decided efﬁciently
by comparing indices written in canonical form. Two Dims which are equal must simplify
to sums with the same constant component and the same coefﬁci ent on corresponding
variables. For example,
(+x y 5 x) =(+(+x x) 5 y)
is valid because both simplify to 2 x+y+5, whereas
(+q 5 y) =(+(+x x) 5 y)
is false for any interpretation which does not assign qto twice the value assigned to x(and
thus is not valid).
To decide the validity of an equality on Shape s (i.e., sequences of naturals), we can
again test by conversion to a canonical form: a sequence is wr itten out as the concatenation
of singleDims andShape variables. Sorting rules guarantee that the individual ele ments of
a sequence are natural numbers, and associativity permits n ested appends to be collapsed
away. Thus the index
(++(Shp2 (+x 5 x)) (++ d (Shp3)))
--- Page 12 ---
ZU064-05-FPR paper 2 July 2019 1:24
12 Justin Slepak, Olin Shivers and Panagiotis Manolios
canonicalizes to
(++(Shp2) (Shp(+x x 5)) d (Shp3))
To show that this process does produce a canonical form, cons ider two shapes in this
form which differ, and focus on the leftmost differing posit ion in their respective lists of
appended components. If they are syntactically different s ingleton shapes—their respective
contents are two different canonicalized naturals—then an assignment under which those
naturals differ will also make the full shapes differ at this position. If one is a singleton
(Shp ι)and the other a variable s(of sortShape ), then an interpretation which assigns
the variables in ιsuch that its components sum to nmay also assign sto be the shape
(Shp(+ n1)). Again, an interpretation forces the shapes to be unequal. F inally, if this
position has variables sandt, choose an interpretation mapping sto(Shp1) andtto
(Shp2) to produce unequal interpretations of the whole shapes.
Although type checking itself only requires this canonical ization process, constraint-
based type inference would call for a more sophisticated sol ver due to the use of existential
variables for choosing pieces of an index.
In order to describe when arguments’ shapes are compatible, it is useful to impose a
lattice structure on the universe of shapes. The lattice is b uilt with the order ⊑meaning
that one shape is a preﬁx of another; a ⊤is added to represent the join of incompatible
shapes (we already have ⊥=/square, as the empty shape is a preﬁx of every shape). For shapes
s0ands1, we have s0⊔s1/ne}a⊔ionslash=⊤if and only if s0⊑s1ors1⊑s0. Generalizing to arbitrary
ﬁnite joins,/unionsqdisplay
{s...}/ne}a⊔ionslash=⊤implies that the shapes s...are totally ordered, and the lattice
structure means the shapes’ join is one of the shapes themsel ves.
2.3 Static Semantics
Typing Core Remora uses a three-part environment structure :Θis a partial function map-
ping index variables to sorts; ∆maps type variables to their kinds; and Γmaps term
variables to their types. The stratiﬁcation of Dependent ML -style types allows indices to
be checked using only the sort environment and types using on ly the sort and kind environ-
ments. Following the deﬁnition of each judgment form, we giv e a handful of lemmas which
will be needed for a type soundness argument in Subsection 2. 5. The well-formedness
judgments each come with a lemma stating that the judgment gi ves a unique result to each
well-formed term and that unique result is preserved by subs tituting well-formed assign-
ments for free variables. When we show type soundness for Rem ora, these results will be
needed to prove the preservation lemma. Uniqueness of typin g is particularly important
for Remora, where the implicit iteration in function applic ation (including index and type
abstractions) is driven by the types ascribed to the functio n and argument expressions.
Well-deﬁned program behavior relies on having a unique deco mposition of each array into
a frame of cells.
2.3.1 Sorting
Figure 5 deﬁnes the sorting judgment, Θ⊢ι::γ, which states that in sort environment
Θ, the index ιhas sort γ. Natural number literals have sort Dim. A sequence of indices is
aShape , provided that every element of the sequence is a Dim. Addition is used on Dim
--- Page 13 ---
ZU064-05-FPR paper 2 July 2019 1:24
The Semantic Foundations of Rank Polymorphism 13
Θ⊢ι::γ
n∈N
Θ⊢n::DimS-N AT(x::γ)∈Θ
Θ⊢x::γS-V ARΘ⊢ιj::Dim for each j
Θ⊢(Shp ι...)::ShapeS-S HAPE
Θ⊢ιj::Dim for each j
Θ⊢(+ι...)::DimS-P LUSΘ⊢ιj::Shape for each j
Θ⊢(++ι...)::ShapeS-A PPEND
Fig. 5. Sorting rules
arguments to produce a Dim.Shape arguments may be appended, to form another Shape .
Variables may be bound at either sort, but they can only be int roduced into the environment
by index abstraction and unboxing terms—the index language itself has no binding forms.
We give two results about the well-behaved nature of the sort ing rules: No index inhabits
both sorts (in the same environment), and replacing an index ’s variables with appropriately-
sorted indices does not change the sort.
Lemma 2.1 (Uniqueness of sorting )
IfΘ⊢ι::γandΘ⊢ι::γ′, then γ=γ′.
Proof
No non-variable index form is compatible with multiple sort ing rules, so they can only have
whichever sort their one compatible rule concludes. It rema ins to show that uniqueness
holds for variables. Since Θis a well-deﬁned partial function, mapping variables to sor ts,
Θ(x)can only have one value. If Θ(x)=γandΘ(x)=γ′,γ=γ′.
Lemma 2.2 (Preservation of sorts under index substitution )
IfΘ,x::γx⊢ι::γandΘ⊢ιx::γxthen Θ⊢ι[x/maps⊔o→ιx]::γ.
Proof
This is straightforward induction on the original sort deri vation.
2.3.2 Kinding
Kinding rules are given in ﬁgure 6. The Array kind is only ascribed to types built by the
array type constructor and type variables bound at that kind . The array type constructor
requires as its arguments an Atom type and a Shape index. Base types are fundamental,
non-aggregate types, such as Float orBool , so they are Atom s. Function types have kind
Atom , but their input and output types must be Array s. This reﬂects the rule that application
is performed on arrays, and the function produces an array re sult. Similarly, universal types
and dependent products, describing type and index abstract ions, must have an Array as
their body, while they themselves are Atom s. This rules out types whose inhabitants would
have to be syntactically illegal due to containing expressi ons instead of atoms as their
bodies. Since boxes present arrays as atoms, dependent sum t ypes also have an Array body
and are kinded as Atom s. A universal type adds bindings for its quantiﬁed type vari ables to
∆. Dependent products and sums do the same for their index vari ables in Θ.
As with sorting of indices, we expect a well-kinded type to in habit only a single kind
(ﬁxing a particular environment). The kinding system shoul d also allow free index or
--- Page 14 ---
ZU064-05-FPR paper 2 July 2019 1:24
14 Justin Slepak, Olin Shivers and Panagiotis Manolios
Θ;∆⊢τ::k
(x::k)∈∆
Θ;∆⊢x::kK-V ARΘ;∆⊢B::AtomK-B ASEΘ;∆⊢τj::Array for each j
Θ;∆⊢τ′::Array
Θ;∆⊢(->( τ...)τ′)::AtomK-F UN
Θ;∆,x::k...⊢τ::Array
Θ;∆⊢(Forall(( x k)...)τ)::AtomK-U NIVΘ,x::γ...;∆⊢τ::Array
Θ;∆⊢(Pi(( xγ)...)τ)::AtomK-P I
Θ,x::γ...;∆⊢τ::Array
Θ;∆⊢(Sigma(( xγ)...)τ)::AtomK-S IGMA
Θ⊢ι::Shape Θ;∆⊢τ::Atom
Θ;∆⊢(Arr τ ι)::ArrayK-A RRAYK-A RRAY
Fig. 6. Kinding rules
type variables to be replaced with appropriately sorted or k inded indices or types without
changing the original type’s kind.
Lemma 2.3 (Uniqueness of kinding )
IfΘ;∆⊢τ::kandΘ;∆⊢τ::k′, then k=k′.
Proof
As with uniqueness of sorting, no non-variable type is compa tible with multiple kinding
rules. Since all kinding rules except for K-V ARascribe a speciﬁc kind, the only remaining
case is for type variables. The kind environment ∆is a well-deﬁned partial function, so
∆(x)=kand∆(x)=k′imply k=k′.
Lemma 2.4 (Preservation of kinds under index substitution )
IfΘ,x::γ;∆⊢τ::kandΘ⊢ι::γthen Θ;∆⊢τ[x/maps⊔o→ιx]::k.
Proof
This is straightforward induction on the original kind deri vation.
Lemma 2.5 (Preservation of kinds under type substitution )
IfΘ;∆,x::kx⊢τ::kandΘ;∆⊢τx::kxthen Θ;∆⊢τ[x/maps⊔o→τx]::k.
Proof
This is also provable by induction on the kind derivation for τ.
2.3.3 Typing
The typing rules in Figure 7 relate a full environment ( Θmapping index variables to sorts,
∆mapping type variables to kinds, and Γmapping term variables to types), a term (whether
an atom or an expression), and its type under that environmen t. Since an array type might
have its shape described in multiple different ways, e.g., a vector of length 6 or a vector of
length 1+5, the T-E QVrule makes reference to a type equivalence judgment (presen ted
in full detail in §2.3.4) which reconciles such differences according to the algebraic theory
of type indices (presented earlier in §2.2).
--- Page 15 ---
ZU064-05-FPR paper 2 July 2019 1:24
The Semantic Foundations of Rank Polymorphism 15
Θ;∆;Γ⊢t:τ
Θ;∆;Γ⊢o:S/llbracketo/rrbracketT-O P(x:τ)∈Γ
Θ;∆;Γ⊢x:τT-V ARΘ;∆;Γ⊢t:τ′τ∼=τ′
Θ;∆;Γ⊢t:τT-E QV
Θ;∆;Γ⊢aj:τfor each j
Θ;∆⊢τ::Atom
Length /llbracketa.../rrbracket=∏n...
Θ;∆;Γ⊢(array( n...)a...)
:(Arr τ(Shp n...))T-A RRAYΘ;∆⊢τ::Atom
0∈n...
Θ;∆;Γ⊢(array( n...)τ)
:(Arr τ(Shp n...))T-0A
Θ;∆;Γ⊢ej:(Arr τ ι)for each j
Θ;∆⊢(Arr τ ι)::Array
Length /llbrackete.../rrbracket=∏n...
Θ;∆;Γ⊢(frame( n...)e...)
:(Arr τ(++(Shp n...)ι))T-F RAMEΘ;∆⊢τ::Atom
Θ⊢ι::Shape 0∈n...
Θ;∆;Γ⊢(frame( n...)(Arr τ ι))
:(Arr τ(++(Shp n...)ι))T-0F
Θ;∆;Γ,x:τ...⊢e:τ′
Θ;∆⊢τ::Array for each j
Θ;∆;Γ⊢(λ((xτ)...)e)
:(->( τ...)τ′)T-L AMΘ;∆,x::k...;Γ⊢v:τ
Θ;∆;Γ⊢(Tλ((x k)...)v)
:(Forall(( x k)...)τ)T-TL AM
Θ,x::γ...;∆;Γ⊢v:τ
Θ;∆;Γ⊢(Iλ((xγ)...)v)
:(Pi(( xγ)...)τ)T-IL AMΘ⊢ι::γfor each j
Θ;∆⊢(Sigma(( xγ)...)τ)::Atom
Θ;∆;Γ⊢e:τ[x/maps⊔o→ι,...]
Θ;∆;Γ⊢(box ι...e(Sigma(( xγ)...)τ))
:(Sigma(( xγ)...)τ)T-B OX
Θ;∆;Γ⊢e:(Arr(Forall(( x k)...)(Arr τuιu))ιf) Θ;∆⊢τj::kjfor each j
Θ;∆;Γ⊢(t-app eτ...):(Arr τu[x/maps⊔o→τ,...](++ιfιu))T-TA PP
Θ;∆;Γ⊢e:(Arr(Pi(( xγ)...)(Arr τpιp))ιf) Θ⊢ιj::γjfor each j
Θ;∆;Γ⊢(i-app eι...):(Arr τp[x/maps⊔o→ι,...](++ιfιp[x/maps⊔o→ι,...]))T-IA PP
Θ;∆;Γ⊢es:(Arr(Sigma(( x′
iγ)...)τs)ιs)
Θ,xi::γ...;∆;Γ,xe:τs/bracketleftbig
x′
i/maps⊔o→xi,.../bracketrightbig
⊢eb:(Arr τbιb)
Θ;∆⊢(Arr τbιb)::Array
Θ;∆;Γ⊢(unbox( xi...xees)eb):(Arr τb(++ιsιb))T-U NBOXT-U NBOX
Θ;∆;Γ⊢ef:(Arr(->((Arr τ ι)...)(Arr τ′ι′))ιf)
Θ;∆;Γ⊢ea:(Arr τ(++ιaι))... ιp=/unionsqdisplay/braceleftbig
ιfιa.../bracerightbig
Θ;∆;Γ⊢(efea...):(Arr τ′(++ιpι′))T-A PP
Fig. 7. Typing rules
The signature S, referenced in the T-O Prule, is a function mapping from primitive op-
erators to their types. For example, S/llbracket+/rrbracketis(-> ((Arr Num (Shp)) (Arr Num (Shp)))
(Arr Num (Shp))) , meaning +is an operator which consumes two scalar numbers and
produces one scalar number.
Array literals and nested frames both include a length check : the number of atoms or
cells must be equal to the product of the given dimensions. In the case of empty arrays,
--- Page 16 ---
ZU064-05-FPR paper 2 July 2019 1:24
16 Justin Slepak, Olin Shivers and Panagiotis Manolios
the length matching condition is fulﬁlled if and only if the a rray has a 0as one of its
dimensions. Term, type, and index abstractions all bind the ir arguments’ names in the
appropriate environment.
Typing function application starts by identifying the type of the expression in function
position. It must be an array of functions, and the array’s en tire shape ιfis treated as
the function frame. The function input types, also arrays, s pecify the element type and
cell shape for each argument. Each cell shape ιmust be a sufﬁx of the shape of the
corresponding actual argument; the remainder ιais the argument’s frame. The maximum of
these frames under preﬁx ordering (where [23]⊑[232]but[23]/ne}a⊔ionslash⊑[632]) is the principal
frame ιp. That is, the function and argument arrays will all be lifted so as to have ιpas their
frames when the program runs. Then ιpis used as the frame around the function’s output
type to give the result type for this function application.
Type and index application also require arrays in function p osition, but they can skip
preﬁx comparison as type and index arguments do not come in ar rays that must be split
into frames of cells. Thus the function’s frame shape ιfpasses through unaltered, and
arguments are substituted into the body type τbto produce the resulting array’s element
type.
When constructing a box, a dependent-sum type annotation is provided. The box’s
index components must match their declared sorts, and subst ituting them into the body
of the dependent sum type must produce a type that matches the box’s array component.
Unboxing requires that ebox, the expression being destructed, be a dependent sum. The
unbox form names the sum’s index and array components and add s them to the sort and
type environments when checking ebody. Although the index components are in scope
while checking the body, information hidden by the existent ial is not permitted to leak
out: The end result type τbodymust be well-formed without relying on the extended sort
environment. Unboxing a frame of boxes (scalars) produces a frame of result cells, similar
to lifting function application.
Anticipating a progress lemma, we prove a canonical-forms l emma for Remora’s typing
rules. Following the atom/array distinction, we have separ ate lemmas for atoms and arrays.
Although an atom can contain an array if that atom is a box, we a void mutual dependence
between the lemmas by not making any claim about the syntacti c structure of the box’s
contents.
Lemma 2.6 (Canonical forms for atomic values )
Letvbe a well-typed atomic value, that is, ·;·;·⊢v:τ.
1. If τis of the form (->( τi...)τo),
thenvis of the form oor(λ((xτi)...)e).
2. If τis of the form (Forall(( x k)...)τu),
thenvis of the form (Tλ((xuk)...)v).
3. If τis of the form (Pi(( xγ)...)τp),
thenvis of the form (Iλ((xpγ)...)v).
4. If τis of the form (Sigma(( xγ)...)τb),
thenvis of the form (box ι...vb(Sigma(( xbγ)...)τ′
b)),
with τ∼=(Sigma(( xbγ)...)τ′
b).
--- Page 17 ---
ZU064-05-FPR paper 2 July 2019 1:24
The Semantic Foundations of Rank Polymorphism 17
τ∼=τ′
τ∼=τTEQV-REFLτ∼=τ′VALID/largellbracket
ι≡ι′/largerrbracket
(Arr τ ι)∼=(Arr τ′ι′)TEQV-ARRAY
τij∼=τ′
ijfor each j τo∼=τ′
o
(->( τi...)τo)∼=(->( τ′
i...)τ′
o)TEQV-FN
τ/bracketleftbig
x/maps⊔o→xf,.../bracketrightbig∼=τ′/bracketleftbig
x′/maps⊔o→xf,.../bracketrightbig
with fresh xf...
(Forall(( x k)...)τ)∼=(Forall(( x′k)...)τ′)TEQV-UNIV
τ/bracketleftbig
x/maps⊔o→xf,.../bracketrightbig∼=τ′/bracketleftbig
x′/maps⊔o→xf,.../bracketrightbig
with fresh xf...
(Pi(( xγ)...)τ)∼=(Pi(( x′γ)...)τ′)TEQV-PI
τ/bracketleftbig
x/maps⊔o→xf,.../bracketrightbig∼=τ′/bracketleftbig
x′/maps⊔o→xf,.../bracketrightbig
with fresh xf...
(Sigma(( xγ)...)τ)∼=(Sigma(( x′γ)...)τ′)TEQV-SIGMA
Fig. 8. Type equivalence
5. If τis of the form B,
thenvis of the form b.
Proof
The type derivation may end with T-E QV, so we consider the subderivation prior to all
ﬁnal T-E QVinstances. We then examine which typing rules can ascribe a t ype of the right
form and the identify what form the term must take to match tho se rule.
Lemma 2.7 (Canonical forms for arrays )
Letvbe a well-typed value, that is, ·;·;·⊢v:τ,
1. If τis of the form (Arr(->( τi...)τo)ι),
then vis of the form (array( n...)f...).
2. If τis of the form (Arr(Forall(( x k)...)τu)ι),
then vis of the form (array( n...)(Tλ((xuk)...)vu)...).
3. If τis of the form (Arr(Pi(( xγ)...)τp)ι),
then vis of the form (array( n...)(Iλ((xpγ)...)vu)...).
4. If τis of the form (Arr(Sigma(( xγ)...)τb)ι),
then vis of the form (array( n...)(box ι...vb(Sigma(( xbγ)...)τb))...),
with τ∼=(Sigma(( xbγ)...)τ′
b).
5. If τis of the form (Arr Bι),
then vis of the form (array( n...)b...),
with·;·;·⊢b:Bfor each of b....
Proof
This proceeds like the proof for Lemma 2.6.
2.3.4 Type equivalence
Remora’s typing rules rely on a type-equivalence relation d eﬁned in Figure 8. The equiv-
alence relation is essentially α-equivalence augmented with a check as to whether array
--- Page 18 ---
ZU064-05-FPR paper 2 July 2019 1:24
18 Justin Slepak, Olin Shivers and Panagiotis Manolios
shapes are guaranteed to be equal. We expect the relation ∼=actually to be an equivalence
relation, i.e., reﬂexive, symmetric, and transitive. Only reﬂexivity has its own inference
rule, so we now show symmetry and transitivity.
Lemma 2.8 (Symmetry of ∼=)
Ifτ∼=τ′, then τ′∼=τ.
Proof
This follows via straightforward induction on the derivati on of τ0∼=τ1.
Lemma 2.9 (Transitivity of ∼=)
Ifτ0∼=τ1andτ1∼=τ2, then τ0∼=τ2.
Proof
This follows from induction on the derivations of τ0∼=τ1andτ1∼=τ2. Since both deriva-
tions τ1, the structure of the equivalence rules prohibits the deriv ations from ending with
different rules (other than TE QV-REFL, which passes that structural requirement on to its
premises).
Theorem 2.1
∼=is an equivalence relation.
A type-equivalence relation should not cross kind boundari es. Violation of this principle
would allow use of T-E QVto ascribe an ill-kinded type to a well-typed term. It follow s
directly from inspection of the equivalence rules that they will not relate an Atom with an
Array , but correct use of type and index variables remains to be pro ven. To that end, we
show that two equivalent types will be ascribed the same kind by the same environment.
Lemma 2.10
IfΘ;∆⊢τ::kandτ∼=τ′, then Θ;∆⊢τ′::k.
Proof
This result is proven induction on the derivation of τ∼=τ′. In each case, the induction
hypothesis converts a kind derivation for some fragment of τinto a kind derivation for a
corresponding fragment of τ′(and similar for index fragments).
We also expect type equivalence to be well-behaved under sub stitution. Ultimately,
substituting equivalent types or indices into equivalent t ypes ought to produce equivalent
types. Proving that result by induction on derivation of equ ivalence is straightforward
except for the R EFLcase.
Lemma 2.11
If V ALID/llbracketι≡ι′/rrbracket, then for any index variable x,τ[x/maps⊔o→ι]∼=τ[x/maps⊔o→ι′].
Proof
This is provable using induction on the structure of τ. Only the case for arrays makes direct
use of ιandι′; the other cases simply use the induction hypothesis to prov e the premises
of the derivation of τ[x/maps⊔o→ι]∼=τ[x/maps⊔o→ι′].
Lemma 2.12
Ifτx∼=τ′
x, then for any type variable x,τ[x/maps⊔o→τx]∼=τ[x/maps⊔o→τ′
x].
--- Page 19 ---
ZU064-05-FPR paper 2 July 2019 1:24
The Semantic Foundations of Rank Polymorphism 19
Proof
We use induction on the structure of τ. The cases for universals, dependent products, and
dependent sums require instantiating the induction hypoth esis with a substitution of fresh
type variables xf.... For example, when τ=(Forall(( xuk)...)τu), the induction
hypothesis promises the equivalence of τuafter substituting in xf...forxu...andalso τx
orτ′
xforx.
Theorem 2.2
Ifτ∼=τ′andτx∼=τ′
x, then for any type variable x,τ[x/maps⊔o→τx]∼=τ′[x/maps⊔o→τ′
x].
Proof
We use induction on the derivation of τ∼=τ′. In each case, the induction hypothesis
provides equivalence derivations for corresponding fragm ents of τ[x/maps⊔o→τx]andτ′[x/maps⊔o→τ′
x],
which can then be used to prove the substituted types themsel ves equivalent.
Having deﬁned the typing judgment and the type-equivalence relation on which it builds,
we can now prove the usual results about typing in Remora. The T-E QVrule can allow
many types to be ascribed to a single term, but we will prove th at an environment and term
can only map to a single equivalence class.
Theorem 2.3 (Uniqueness of typing, up to equivalence )
IfΘ;∆;Γ⊢t:τandΘ;∆;Γ⊢t:τ′, then τ∼=τ′.
Proof
This can be proven by induction on t, showing that all derivations of Θ;∆;Γ⊢t:τ′must
end with the same non-T-E QVrule (chosen according to the structure of t) followed by 0
or more T-E QVinstances, which keeps the result in the same equivalence cl ass as τ.
We also require guarantees about substitution in terms: rep lacing an index variable with
an appropriately-sorted index, a type variable with an appr opriately-kinded type, or a term
variable with an appropriately-typed expression should no t change the type of the original
term. If substitution turns a term twith type τintot′with type τ′, where τ∼=τ′, we can add
a T-E QVat the end of the new type derivation to conclude t′has type τ. As such, we do
not need to include an “up to equivalence” caveat when statin g the preservation of typing
lemmas.
Lemma 2.13 (Preservation of types under index substitution )
IfΘ,x::γ;∆;Γ⊢t:τandΘ⊢ι::γthen Θ;∆;Γ[x/maps⊔o→ιx]⊢t[x/maps⊔o→ιx]:τ[x/maps⊔o→ιx].
Proof
This is straightforward induction on the derivation of Θ,x::γ;∆;Γ⊢t:τ.
Lemma 2.14 (Preservation of types under type substitution )
IfΘ;∆,x::k;Γ⊢t:τandΘ;∆⊢τx::kthen Θ;∆;Γ[x/maps⊔o→τx]⊢t[x/maps⊔o→τx]:τ[x/maps⊔o→τx].
Proof
This is straightforward induction on the derivation of Θ;∆,x::k;Γ⊢t:τ.
Lemma 2.15 (Preservation of types under term substitution )
IfΘ;∆;Γ,x:τx⊢t:τandΘ;∆;Γ⊢ex:τxthen Θ;∆;Γ⊢t[x/maps⊔o→ex]:τ.
--- Page 20 ---
ZU064-05-FPR paper 2 July 2019 1:24
20 Justin Slepak, Olin Shivers and Panagiotis Manolios
Proof
We use induction on the derivation of Θ;∆;Γ,x:τx⊢t:τ.
We call an environment well-formed, noted as Θ;∆⊢Γ, if for every binding x:τ∈Γ,
we can derive Θ;∆⊢τ::Array . This is the expected case, rather than permitting τto have
kindAtom , because a lone variable is an expression and ought to stand f or an array value.
When we show that the typing judgment only ascribes types of t he appropriate kind,
the case for the T-E QVrule relies on the earlier lemma that the type equivalence re lation
respects kinding, i.e., two equivalent types will have the same kind when checked in the
same environment.
Theorem 2.4 (Ascription of well-kinded types )
Given Θ;∆;Γ⊢t:τwhere Θ;∆⊢Γ:
•Iftis an expression, then Θ;∆⊢τ::Array
•Iftis an atom, then Θ;∆⊢τ::Atom
Proof
This follows from induction on the derivation of Θ;∆;Γ⊢t:τ. It is not sufﬁcient to
point out that each typing rule ascribes a type whose form mat ches the appropriate kind.
Elimination-form cases call for a little extra work. For U NBOX , the kind check on the
result type is necessary to ensure that existentially quant iﬁed variables do not leak out.
The A PPcase must ensure that index variables in the ascribed type ac tually appear in the
environment. This is guaranteed because the principal fram e is always chosen to be one of
the function- or argument-position frames.
2.4 Dynamic Semantics
In the dynamic semantics for Remora, the way function applic ation is lifted to work on
aggregate data depends on the types of the function and argum ent terms. Consulting type
information avoids a “hole” in the semantics of untyped arra y-oriented code, where a frame
whose shape includes a 0 dimension evaluates to an array with indeterminate shape—
there are no concrete cells whose shape can be used to determi ne the overall shape of the
resulting array. Instead, the function’s type tells us the s hape of the resulting cells, even
when there are zero such cells.
The small-step operational semantics, given in Figure 10, a ssumes every atom or ex-
pression has been tagged with its type. For example, β-reduction requires that each atom
in the function position array have input types τ...and that the argument arrays’ types also
match τ.... This matching is still subject to the type equivalence rule s described in §2.3,
e.g., a function tagged as having input type (Array Int (++ (Shp 3) (Shp 4))) can
be applied to an argument tagged with type (Array Int (Shp 3 4)) . Because every
term now has type annotations attached, we drop the “empty” a rray and frame syntactic
forms. Their replacements use the standard array and frame s yntax with an empty list of
atoms or cells, and the atom or cell type is implied by the expr ession’s type annotation.
Several list-processing metafunctions are used in deﬁning the reduction rules. These
metafunctions are deﬁned in Figure 9. Splitnturns a list into a list of lists, made up of the
consecutive length- npieces of the original list. For example, Split3/llbracket(1 2 3 4 5 6) /rrbracketis
--- Page 21 ---
ZU064-05-FPR paper 2 July 2019 1:24
The Semantic Foundations of Rank Polymorphism 21
Splitn/llbracket(a1,..., am)/rrbracket=((a1,..., an),(an+1,..., a2n),...,(am−n+1,..., am))
Repn/llbracket(a1,..., am)/rrbracket=(a1,1,..., a1,n,..., am,1,..., am,n)where ai,j=ai
Concat/largellbracket
((a1,1,..., a1,n),...,(am,1,..., am,n))/largerrbracket
=(a1,1,..., a1,n,..., am,1,..., am,n)
Transpose ((a1,1,..., a1,n),...,(am,1,..., am,n))=((a1,1,..., am,1),...,(an,1,..., am,n))
Fig. 9. List-processing metafunctions
((1 2 3) (4 5 6)) .Concat ﬂattens a list of lists into a single list, effectively rever sing
aSplit.Repnconstructs a new list by repeating each element of the origin al list ntimes.
Rep2/llbracket(0 1) /rrbracketis(0 0 1 1) . Used on nested lists, the inner lists are treated atomicall y:
Rep2/llbracket((1 2 3) (4 5 6)) /rrbracketis((1 2 3) (1 2 3) (4 5 6) (4 5 6)) .Transpose takes
a list of lists, where the inner lists all have the same length , and produces a new list of lists
whose ithelement contains the ithelements of each original inner list.
The reduction rules themselves are given in Figure 10. Remor a’s function application
is split into stages for replicating cells to make frame shap es match ( lift), mapping the
functions to corresponding argument cells ( map), and gathering the result cells back into
an array ( collapse ).
Performing a liftstep identiﬁes the function array’s frame, the sequence [nf...], and
each argument’s frame, [na...]. Then the sequence [np...]is chosen to be the largest frame
according to preﬁx ordering. We require that at least one fun ction or argument frame be
different from the principal frame—otherwise, a map step would be appropriate instead.
Each argument’s cell size nacis the product of the dimensions [nin...]of the function’s
input type at that position; the function array’s cell size i s always 1. The number of replicas
needed for each cell ( nfefor the function and nfafor each argument) is determined by
multiplying the dimensions that must be added to each corres ponding frame to produce
the principal frame, i.e., the principal frame minus whatever preﬁx was already prese nt
in the original array’s shape. Given these numbers, we split each array’s atom list into its
cells, replicate those cells to match the new array shapes, a nd then concatenate each array’s
replicated cells to produce the new function and argument ar rays. Type annotations on the
individual arrays update to reﬂect their new shapes, but the application form’s type remains
unchanged.
Amap step is possible when every piece of a function application h as the same frame
shape. Then the application becomes a frame of application forms, which themselves all
have scalar principal frame. This requires breaking each ar gument array’s atom list into its
individual cells’ atom lists, then transposing to match the ﬁrst cell of each argument with
the ﬁrst function, the second cell of each argument with the s econd function, and so on.
When function application has a scalar in function position , and every argument ar-
ray matches the function’s corresponding input type, then w e can β-reduce or δ-reduce.
β-reduction performs conventional λ-calculus substitution. The δrule uses a family of
metafunctions, each associated with a primitive operator. Noframe construct is necessary
in either result, as this is the degenerate case of function l ifting—the principal frame is
scalar.
Applying type and index abstractions is handled by the tβandiβrules. The application
frame is the shape of the array of type or index abstractions, since there are no argument
--- Page 22 ---
ZU064-05-FPR paper 2 July 2019 1:24
22 Justin Slepak, Olin Shivers and Panagiotis Manolios
arrays . EveryTλorIλis applied to the full list of type or index arguments. Substi tution
into the body of each abstraction should be read as affecting type annotations as well as
subterms: if we are replacing the type variable TwithInt, thenx(Array T (Shp 3))becomes
x(Array Int (Shp 3)).
Once aframe has every one of its cells reduced to an array literal, the nested repre-
sentation can be merged into a single literal. In the case whe re one of n...is 0, there will
be no cells to examine to determine the cell dimensions n′..., so this information is taken
from the type annotation on the frame form. The type annotation itself passes through
unchanged. The atom lists from the cells are concatenated to produce the collapased array’s
atom list.
Destructing a boxwith anunbox form behaves like a conventional let. The result is the
body e, where the index variables xi...are replaced with the box’s indices ι..., and the
term variable xeis replaced with the contained array v.
2.5 Type Soundness
The value of a type soundness theorem for Remora is not only as surance that well-typed
programs do not suffer from shape-mismatching errors. It al so ensures that the types as-
cribed to program terms accurately describe the shapes of th e data those terms compute.
That is the guarantee that justiﬁes a compiler’s use of the ty pe system as a static analysis
for array shape.
With supporting lemmas, such as canonical forms and substit ution, already taken care
of, we now establish progress and preservation lemmas. Sinc e we have not committed to a
collection of primitive operators that are all total functi ons, the progress lemma acknowl-
edges the possibility of non-shape errors, such as division by zero. However, we do assume
that any value returned by a primitive operator inhabits tha t operator’s output type.
Lemma 2.16 (Progress )
Given an expression esuch that ·;·;·⊢e:τ, one of the following holds:
•eis a value v
•There exists e′such that e/maps⊔o→e′
•eisE[((array() o)v...)]whereois a partial function applied to appropriately-
typed values outside its domain.
Proof
We use induction on the derivation of ·;·;·⊢e:τ. We consider only cases for typing rules
which apply to expressions (as opposed to atoms). Since we do not reduce under a binder,
our assumed type derivation ensures that the reducible sube xpression of eis also typable
using an empty environment.
Anarray form which is not already a value must have some non-value ato m. That atom
must itself contain a non-value expression, with its own typ e derivation. So the induction
hypothesis implies that it can take a reduction step or is a mi s-applied primitive operator.
Similar reasoning applies to frame forms: either we have a collapse redex, or some cell
subexpression in the frame can make progress.
--- Page 23 ---
ZU064-05-FPR paper 2 July 2019 1:24
The Semantic Foundations of Rank Polymorphism 23
((array ( nf...)vf...)(Arr(->((Arr τi(Shp ni...))...)τo)(Shp nf...))
(array ( na...ni...)va...)(Arr τi(Shp na...ni...))...)
/maps⊔o→lift
((array ( np...)
Concat/Largellbracket
Repnfe/largellbracket
Split1/largellbracket
vf.../largerrbracket/largerrbracket/Largerrbracket
)(Arr(->((Arr τi(Shp ni...))...)τo)(Shp np...))
(array ( np...ni...)
Concat/largellbracket
Repnae/largellbracket
Splitnac/llbracketva.../rrbracket/largerrbracket/largerrbracket
)(Arr τi(Shp np...ni...))...)
where
Not all of/parenleftbig
nf.../parenrightbig
,(na...)...are equal
np... =/unionsqdisplay/largellbracket/parenleftbig
nf.../parenrightbig
(na...).../largerrbracket
nfe=∏/parenleftbig
np.../parenrightbig
∏/parenleftbig
nf.../parenrightbig
nae... =∏/parenleftbig
np.../parenrightbig
∏(na...)... nac... =/parenleftbig∏(ni...)/parenrightbig
...
((array ( nf...)vf...)(Arr(->((Arr τi(Shp ni...))...)τo)(Shp nf...))
(array ( nf...ni...)va...)(Arr τi(Shp nf...ni...))...)
/maps⊔o→map
(frame ( nf...)
((array () vf)(Arr(->((Arr τi(Shp ni...))...)τo)(Shp))
(array ( ni...)vc...)(Arr τi(Shp ni...))...)τo...)
where
nc... =(∏ni...)...
((vc...)...)... =Transpose/largellbracket
Splitnc/llbracketva.../rrbracket.../largerrbracket
Length/largellbracket
nf.../largerrbracket
> 0
((array () ( λ((xτ)...)e))vτ...)
/maps⊔o→βe[x/maps⊔o→vτ,...]
(t-app (array ( n...) (T λ((x k)...)e)...)τ...)
/maps⊔o→tβ(frame ( n...)e[x/maps⊔o→τ,...]...)
(i-app (array ( n...) (I λ((xγ)...)e)...)ι...)
/maps⊔o→iβ(frame ( n...)e[x/maps⊔o→ι,...]...)
(frame ( n...) (array ( n′...)v...)...)(Arr τ(Shp n...n′...))
/maps⊔o→collapse(array ( n...n′...)Concat /llbracket(v...).../rrbracket)(Arr τ(Shp n...n′...))
(unbox ( xi...xe(array ( ns...) (box ι...vτ)...))e)
/maps⊔o→unbox(frame ( ns...)e[xi/maps⊔o→ι,..., xe/maps⊔o→v])
Fig. 10. Dynamic semantics for Remora
Anunbox form can either make progress in the box position (via the ind uction hypoth-
esis) or take an unbox step. Similarly, a type or index applications can make progr ess in
function position or take tβoriβstep.
The function application case splits into subcases dependi ng on whether the function
and argument arrays are fully reduced and if so what their fra me shapes are. If they are all
--- Page 24 ---
ZU064-05-FPR paper 2 July 2019 1:24
24 Justin Slepak, Olin Shivers and Panagiotis Manolios
value forms, we have all scalar frames (a βorδredex) or all identical non-scalar frames (a
map redex), or non-identical preﬁx-compatible frames (a liftredex). Preﬁx-incompatible
frames are ruled out by the type derivation.
Lemma 2.17 (Preservation )
LetΘ,∆,Γbe a well-formed environment, i.e.,Θ;∆⊢Γ. IfΘ;∆;Γ⊢e:τande/maps⊔o→e′then
Θ;∆;Γ⊢e′:τ.
Proof
We use induction on the derivation of ·;·;· ⊢e:τ. Anarray form which can take a
reduction step must contain a reducible subexpression. Man y typing rules give rise to
subcases where the eitself is not a redex but contains some subexpression erwhich steps
toe′
r. In these situations, the typing derivation for eris included in that for e, so replacing
that subderivation with one for e′
r(deriving the same type, according to the induction
hypothesis) produces a derivation of ·;·;·⊢e′:τ.
The remaining nontrivial subcases each correspond to parti cular reduction rules. As in
proving Progress, the T-A PPcase is split into subcases based on the function and argumen t
frames. When frames are non-identical but preﬁx-compatibl e, the resulting liftreduction
produces an application form with the same principal frame a nd thus the same result type.
When we have identical non-scalar frames, the map reduction produces a frame form
whose frame shape is equal to the application form’s princip al frame and whose cell shape
and atom type is the same as the function’s return shape and at om type. This gives it
a type equivalent to that of the map redex. With a scalar principal frame, we have a δ
redex (trivial) or βredex (follows from Lemma 2.15, preservation of types under term
substitution). Reasoning for type and index application fo rms is similar (via Lemma 2.13
and Lemma 2.14 respectively). A reducible unbox form also substitutes a value in for a
variable which is intended to have the same type, so Lemma 2.1 5 again ensures the result
type is τ.
Theorem 2.5 (Type soundness )
If·;·;· ⊢e:τ, then either ediverges, there exists vsuch that e/maps⊔o→∗vand·;·;· ⊢v:τ,
or there exist partial function oand appropriately-typed arguments v...such that e/maps⊔o→∗
E[((array() o)v...)].
Proof
We argue coinductively using the sequence of reduction step s from e. For any well-typed
e, Progress (Lemma 2.16) implies that either ehas the form v,ehas the form E[((array
()o)v...)], ore/maps⊔o→e′. In the ﬁrst case, the reduction sequence terminates in a val ue,
so we have e/maps⊔o→∗v. Furthermore, Preservation (Lemma 2.17) implies that ·;·;·⊢v:τIn the
second case, the reduction sequence terminates in a mis-app lied primitive operator. In the
third case, Preservation implies that ·;·;·⊢e′:τ.
