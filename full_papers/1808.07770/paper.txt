Transpiling Programming Computable Functions
to Answer Set Programs

arXiv:1808.07770v1 [cs.PL] 23 Aug 2018

Ingmar Dasseville, Marc Denecker
KU Leuven, Dept. of Computer Science, B-3001 Leuven, Belgium.
ingmar.dasseville@cs.kuleuven.be
marc.denecker@cs.kuleuven.be

Abstract. Programming Computable Functions (PCF) is a simplified
programming language which provides the theoretical basis of modern
functional programming languages. Answer set programming (ASP) is
a programming paradigm focused on solving search problems. In this
paper we provide a translation from PCF to ASP. Using this translation
it becomes possible to specify search problems using PCF.

1

Introduction

A lot of research aims to put more abstraction layers into modelling languages
for search problems. One common approach is to add templates or macros to a
language to enable the reuse of a concept [6,7,11]. Some languages such as HiLog
[3] introduce higher order language constructs with first order semantics to mimic
this kind of features. While the lambda calculus is generally not considered a
regular modelling language, one of its strengths is the ability to easily define
abstractions. We aim to shrink this gap by showing how the lambda calculus
can be translated into existing paradigms. Our end goal is to leverage existing
search technology for logic programming languages to serve as a search engine
for problems specified in functional languages.
In this paper we introduce a transpiling algorithm between Programming
Computable Functions, a programming language based on the lambda calculus
and Answer Set Programming, a logic-based modelling language. This transpilation is a source-to-source translation of programs. We show how this can be
the basis for a functional modelling language which combines the advantages
of easy abstractions and reasoning over non-defined symbols. Transpiling Programmable Computable Functions to other languages like C [10], or a theorem
prover like Coq [5] has been done before. But as far as the authors are aware,
no approaches to translate it into logic programs have been done before.
In Section 2 we introduce the source language of our transpiler: Programming
Computable Functions. In Section 3 we introduce the target language of our
transpiler: Answer Set Programming. In Section 4 we describe the translation
algorithm. Finally, in Section 5 we motivate why this kind of translation can
be useful in practice. An implementation of the translator is made available
online (https://dtai.cs.kuleuven.be/krr/pcf2asp), where it can be tested
with your own examples.

2

Programming Computable Functions

Programming Computable Functions [8,15] (PCF) is a programming language
based on the lambda calculus. It is not used as an end-user language; instead it
provides a strong theoretical basis for more elaborate languages, such as Lisp,
Caml or Haskell. There are many small variations of PCF, some extend it with
booleans, tuples or arithmetic operators. One such variation is known as MiniML [4]. The particular flavor is irrelevant for the principles in this paper.
2.1

Syntax

The syntax of PCF relies heavily on the standard lambda calculus, extended
with natural numbers, a selection construct and a fixpoint operator. We identify
the following language constructs:
– function application e1 e2 , which is left associative,
– a lambda abstraction λx.e, abstracting the variable x out of the expression
e,
– for each numeral n ∈ N, a constant n,
– constants succ, representing the successor function over N, pred representing
the predecessor function over N,
– a constant fix, representing the fixpoint operator, also known as the Ycombinator, and
– a ternary language construct ifz ez then et else ee , representing an if
zero-then-else.
Suppose that I is an infinite supply of identifiers. The syntax of PCF can be
inductively defined as:
e = x (∈ I) | e e | λx . e
| n (∈ N) | succ | pred | fix | ifz e then e else e
Example 1. (λx. succ (succ x)) (succ 0) is a complicated way to write 3.
The expression fix allows us to write functions which would require recursive
definitions in most programming languages. It takes a function f as argument
and returns the fixpoint x of that function so that f (x) = x. From this it follows
that fix satisfies the equation fix f = f (fix f ).
Example 2. A traditional recursive definition for the double of a number x could
be:
double x = ifz x then 0 else 1 + 1 + double (x-1)
It is possible to rewrite this using fix, by abstracting both double and x, and
using pred and succ for the increments and decrements:
fix (λdouble. λx. ifz x then 0 else succ (succ (double (pred x))
The informal meaning of this expression is the doubling function.
Example 3. fix (λplus. λa. λb. ifz a then b else plus (pred a) (succ b))
of which the informal meaning is the binary sum function over natural numbers.
2

2.2

Operational Semantics

When considering expressions, we traditionally consider only those without free
variables. However, when considering the operational semantics, we will generalise this to situations where free variables can occur. For this reason we introduce environments and closures through a mutually inductive definition.
Definition 1. An environment E is a mapping from identifiers to closures. A
closure (E,e) consists of an environment E and an expression e, where the environment must interpret at least all the free variables in e.
We say an environment interprets an identifier x if it contains a mapping for x.
The closure to which E maps an interpreted variable x is written as E[x].
Example 4. (succ a,{a 7→({},succ 0)}) is a valid closure which will evaluate to
the number 2.
Evaluation context The evaluation relation ⇓ is a relation between closures
and values, which we will write as follows:
E, e ⇓ V
(E,e) is the closure that is being evaluated. When considering the evaluation
of an expression without an explicit environment, we assume it has no free
variables and we interpret this is as the closure with the empty environment.
V is the value that corresponds to the expression, this can either be a natural
number or a closure. A natural number can be implicitly used as a closure
with the empty environment.
Notation We will describe both the semantics of PCF and the translation
algorithm using a set of inference rules. These are rules of the form
Premise1

...
Premisen
Conclusion

An algorithmic interpretation of these rules will lead to a program which can
evaluate/translate PCF. Most often, the easiest way to read this kind of rules is
bottom up.
Evaluation Rules The following inference rules determine the operational semantics for PCF through the evaluation relation ⇓ .

E[x]=(E2 ,e)
E2 , e ⇓ V
E, x ⇓ V
3

E, e1 ⇓ (E2 , λx.e3 )

E, e2 ⇓ V
E2 ∪ {x 7→ V }, e3 ⇓ Vap
E, e1 e2 ⇓ Vap

E, λx.f ⇓ (E, λx.f )

E, n(∈ N) ⇓ n
E, e ⇓ n
E, succ e ⇓ n + 1
E, e ⇓ n + 1
E, pred e ⇓ n
E, ei ⇓ 0
E, et ⇓ V
E, ifz ez then et else ee ⇓ V
E, ei ⇓ n
n>0
E, ee ⇓ V
E, ifz ez then et else ee ⇓ V
E ∪ {x7→(E, fix (λx.e))}, e ⇓ V
E, fix (λx.e) ⇓ V
These rules form an inductive definition of the evaluation relation ⇓ . Note that
this is a call-by-value semantics. This can be seen in the rule of applications,
as the subexpression e2 is evaluated before adding it to the environment. A
call-by-name semantics would just add the closure containing e2 instead of the
evaluation of e2 .
Example 5. In the below tree you can follow the semantics of an expression using
multiple inference rules. Every horizontal line represents the application of one
evaluation rule.

{x7→2},2 ⇓ 2
{x7→2},x ⇓ 2
{(f 7→(∅,fix (λf. 4))}, 4 ⇓ 4
∅,2 ⇓ 2
{x7→2},pred x ⇓ 1
∅, (fix (λf. 4)) ⇓ 4
4>0
∅,(λx. pred x) 2 ⇓ 1
∅, ifz (fix (λf. 4)) then 3 else (λx. pred x) 2 ⇓ 1
4

Listing 1 An example ASP program and its solutions
1
2
3
4

(a) An ASP Program

(b) The Answer Sets

p (1). p (2). p (3). p (4).
1 { q ( X ) : p ( X ) } 2.
r ( X + Y ) : - q ( X ) , q ( Y ).
: - not r (5).

Answer Set 1:
p (1) p (2) p (3)
q (1) q (4) r (2)
Answer Set 2:
p (1) p (2) p (3)
q (2) q (3) r (4)

3

p (4)
r (5) r (8)
p (4)
r (5) r (6)

Answer Set Programming

Answer Set Programming [1] (ASP) is a modelling language with a strong basis
in logic programming. It is mainly used as a language to specify NP-hard search
problems [14]. There are a lot of different systems supporting a unified ASP
standard[2]. An ASP program is essentially a logic program with some extra
syntactic restrictions. An ASP solver computes the answer sets of the program
under the stable semantics. An answer set consists of a set of atoms which
together represent the solution of a problem. One program may have zero, one
or multiple answer sets.
3.1

Language

An ASP program is a set of rules of the form:
head : - body 1 ,. . ., body n , not body n+1 ,. . ., not body m
The first n body atoms are positive, the others are negative. The head and body
atoms of the rules are of the form id(term1 , . . . ,termn ). Body atoms can also be
comparisons (<,>,=,6=) between terms. Terms can be either constants, variables,
or arithmetic expressions over terms. Constants are numbers or named constants
(strings starting with a lowercase character). Variables are represented as strings
starting with an uppercase character. An ASP program is considered safe if all
rules are safe. A rule is considered safe if all variables occurring in the rule, occur
at least once in a positive body. If the head is omitted, the rule is considered a
constraint. In this case no instantations of the body of the rule should exist such
that all the bodies are true.
Choice rules are a common syntactic extension for ASP. These allow heads
of the form cl {a(X) : b(X) } cu , where cl , cu ∈ N and cl ≤ cu . This head
is considered true if between cl and cu instances of a(X) are true, given b(X).
They allow to easily introduce symbols that are not uniquely defined. We can
for instance declare p to be a singleton containing a number between 1 and 10
with the choice rule: 1 {p(X) : X = 1..10 } 1. The ASP program containing
only this line has 10 answer sets, one for each possible singleton.
5

Example 6. In Listing 1 you can see an example ASP program together with its
answer sets. The first line of the program defines the predicate p as the numbers
between 1 and 4. The second line is a choice rule with no bodies. It states that
q is a subset of p and contains 1 or 2 elements. The third line says that r is the
sum of any two elements (possibly the same one) from q. The fourth line asserts
that r should contain 5.

3.2

Grounding (and Solving)

To understand the details of the translation mechanism, basic knowledge of
how an ASP system constructs an answer set is needed. Constructing answer
sets happens in two phases: grounding and solving [12]. The grounding process
transforms the ASP program to an equivalent propositional program. The solver
then constructs the actual answer sets from this propositional format. The translation from PCF described in this paper will produce a fully positive, monotone
theory without choice rules or constraints. ASP grounders produce the actual
(unique) answer set for this kind of programs. Note that not all ASP systems
use the same algorithms, but the information presented here is common to most
systems.
The grounding process uses a bottom-up induction of the program. At any
point in time, the grounder contains a set of atoms which are possibly part of an
answer set. This set starts empty, and by the end of the process this set contains
an overapproximation of all answer sets. The grounder tries to instantiate rules
using this set of atoms. Whenever a rule is instantiated, the instantiated head
is added to this set, and the ground instantiation of the rule is added to the
grounding of the program. ASP grounders require that all variables occur in a
positive body atom, this is the so-called safety requirement on rules. Safe rules
have the property that only the positive part of the program is essential for
finding all rule instantiations and current grounding approaches heavily rely on
this property.
Example 7. Consider the rule d(X-1) :- d(X), X > 0 and the current set of
grounded atoms is just the singleton {d(1)}. The grounder can now instantiate
the body atom d(X) with X= 1. The other body atom 1 > 0 can be statically
evaluated to be true. This leads to the newly ground rule d(0) :- d(1) and d(0)
is added to the set of grounded atoms. The grounder can now try to instantiate
the rule with X= 0, but the comparison 0 > 0 prevents the rule to be added to
the ground program.
After the grounding phase an ASP solver can produce the actual answer sets
based on the grounding. An ASP solver typically uses a SAT solver extended
with some ASP specific propagators. The inner workings of these programs are
not needed to understand the contents of this paper.
6

4

Translation

In this section we explain the core of the translation mechanism. Section 4.1
defines the relation between the translation and the PCF semantics. Section
4.2 introduces some conventions which explain the structure of the resulting
program. Finally, Section 4.3 explains the static part of the translation. Section
4.4 defines the translation relation between PCF expressions and the dynamic
part of the translation.

4.1

Characterisation of the translation

Translation relation The translation is characterised using a relation
which we will write as follows:

(E,S1 ), e

A, (t,S2 )

E is a mapping from PCF-variables to ASP-terms for at least the free variables
in e. This works analogously to the environment of the PCF semantics, which
was the mapping from PCF-variables to closures.
S1 is a set of ASP atoms ensuring the ASP-terms in E are safe, and constraints
enforcing the ifzero-semantics.
e is the PCF expression that is translated.
A is the ASP program consisting of a set of safe ASP rules, this is the program
that contains all the helper rules to translate e
t is the ASP term which represents the translation of e
S2 is the set of ASP atoms ensuring that t is safe
It can be unintuitive that there are ASP-terms occuring on both sides of the
translation relation. The explanation for this lies in the handling of free variables.
The translation relation will be defined structurally, this means that for the
translation of a composite term, the translation of its subterms are needed. This
implies that when translating the expression (λx. x)), the subterm x needs
to be translated as well. The translation needs some context to interpret this
x and the context of a translation environment will be some information about
the parts which are already translated.
A PCF expression corresponds to a single value, but a logic program corresponds to an answer set with a lot of atoms. We need a way to indicate the
actual value that is meant with the logic program. The result-predicate is used
to indicate the resulting value of the program.
Definition 2. The ASP translation of a PCF expression e determined by
is
the ASP program A such that (∅, ∅), e
A2 , (t, S) and A = A2 ∪{result(t):-S}.
7

Soundness of the translation PCF inherently works on expressions which
evaluate to a particular value, ASP programs define relations. A certain equivalence criterion is needed to validate the translation. For this we use the resultpredicate. For ease of defining the correspondence the soundness criterion is
restricted to programs with a numeric evaluation.
Definition 3. A sound translator for PCF to ASP maps every PCF expression
e to an ASP program A with a unique answer set. This answer set contains at
most one atom for the result-predicate. If ∅, e ⇓ n ∈ N, then result(n) must
be an element of the answer set of A.
Claim. The translation of PCF expressions determined by
lator.

is a sound trans-

In this paper we will not prove this claim. We state it here to give the reader an
intuition about the correspondence between a program and its translation.
4.2

Conventions

In the translation, all PCF expressions e correspond to a tuple (t, S) where t
is an ASP term and S is a set of ASP bodies. Natural numbers have constants
in both PCF and ASP which have a natural correspondence. PCF functions
are identified by an ASP term tf , so that for every ASP term tx , the tuple
(Y, {inter(tf , tx ), Y )}) denotes the image of the function tf applied to tx . All
functions have infinite domains, and thus the full function cannot be represented
in a finite answer set. The domain predicate serves the purpose of making a finite
estimate of the relevant parts of the function. If at some point in the evaluation
of e, the function tf is applied to the value tx , domain(tf , tx ) should be true.
The inter-predicate only needs to be defined for the domain of the function,
resulting in a finite answer set containing the relevant parts of the interpretation
of the function.
Remember that result predicate is used as the predicate determining the
final result of the program. So the translation of a PCF expression is an ASP
program, defining only 3 predicates:
1. inter : determines the interpretation of functions
2. domain : determines the (relevant) domain of functions
3. result: determines the end result
Magic Set Transformation In these conventions a link with the magic set
transformations [13] of logic programs appears. The magic set transformation
allows us to transform a query, which is traditionally executed top-down, to a
program, which can be executed bottom-up. It uses the magic predicates to
indicate which subqueries needs to be performed. As explained in Section 3.2,
ASP uses a bottom-up grounding process. So, the translation from PCF to ASP
also converts a top-down query (the evaluation of PCF) to a bottom-up process
(the ASP grounding). The domain-predicate has a function similar to the magic
predicates: it indicates for which arguments a function needs to be calculated.
8

Listing 2 Static preamble of the ASP translation
1
2
3
4
5
6
7

inter (( pred , X ) ,X -1)
inter (( succ , X ) ,X +1)
inter (( fix , F ) ,Y )
inter (( f ( F ) ,X ) ,Y )
domain (F , f ( F ) )
domain ( FIX , X )

4.3

::::-

domain ( pred , X ) , X > 0.
domain ( succ , X ) .
domain ( fix , F ) , inter (( F , f ( F ) ) ,Y ) .
domain ( f ( F ) ,X ) , inter (( F , f ( F ) ) , FIX ) ,
inter (( FIX , X ) ,Y ) .
: - domain ( fix , F ) .
: - domain ( f ( F ) ,X ) , inter (( F , f ( F ) ) , FIX ) .

Static Preamble

The translation of any PCF expression consists of a dynamic part and a static
part. The static part ensures that the interpetation of the succ, pred and fix
builtins is taken care of. The dynamic part is produced by the translation algorithm and takes care of the actual PCF expression. The static part is the same
for every translation and can be seen in Listing 2. The first two lines of the static
part ensure the right translation of the pred and succ terms. E.g. the PCF-term
succ correctly corresponds to the ASP tuple (succ, {}) according to the conventions defined in Section 4.2. For instance, if somewhere the PCF-term succ 0
needs to be evaluated. The term will translate to (Y, {inter((succ, 0), Y )}) which
will result in Y being equal to 1 in the answer set.
Just like pred and succ, the PCF- and ASP-term of fix are the same. But
the required rules in the preamble are more complex. A naive translation could
look like this:
inter (( fix , F ) ,Z ) : - inter (( fix , F ) ,Y ) , inter (( F , Y ) ,Z ) .
This rule most closely represents fix f = f (fix f ), but in the stable semantics this equation is not correctly represented by the above rule. Instead, an
intermediate term f(F) is introduced to symbolically represent the fixpoint of F
in ASP. Now we are able to write the fixpoint as the function F applied to the
symbolic function f(F) as can be seen on line 3. If the fixpoint is a function, we
need to be able to apply it to arguments. Line 4 serves this purpose: to apply X
to a fixpoint of a function, you can apply F to this fixpoint (to ensure we do not
have the symbolic representation) and then apply X to the result. Finally, lines
6 and 7 ensure that the function applications performed in lines 3 and 4 are all
well-defined through the domain predicates.
4.4

Translation Algorithm

In this section we present the translation algorithm as a definition for the translation relation
using inference rules. Sometimes new ASP constants or variables
are needed in the translation. We suppose there is some global supply of those.
We use the notation head ← B for the ASP rule where head is the head atom
and B is the set of body atoms.
9

Scoping When translating an expression, the free variables in this expression
need to be filled in. As we translate nested expressions level per level, we need
to pass these values along the expression tree. For this reason, we do not just
associate an identifier with a function but a tuple containing an identifier and
the current scope. The current scope is a tupling of the full codomain of the
translation environment E. We will refer to it as scope E .
Builtins (numbers, pred, succ, fix)
(E,S), b
∅, (b,S)
Builtins are relatively easy to translate. The hard work is taken care of by the
static preamble described in Section 4.3. A builtin produces no new ASP rules
and is translated by itself. Safety is however taken into account, not for the
scoping of variables, but for the handling of the if-zero constraints.
Variable
(E,S), x

∅, (E[x],S)

The algorithm carries around a mapping that represents how variables should
be translated. This makes translating it a simple variable easy: just look it up
in the mapping and combine it with the required safety.
Application
(E,S), e1
(E,S), e1 e2

A1 , (t1 , B1 )
(E,S), e2
A2 , (t2 , B2 )
A1 ∪ A2 ∪ ruledomain , (X, body inter ∪ B1 ∪ B2 )
X =a new ASP variable

rule domain ={domain(t1 , t2 ) ← B1 ∪ B2 }
body inter ={inter((t1 , t2 ), X)}
Applications are translated by independently translating the two subexpressions.
The produced ASP programs need to be combined, with the additional rule that
t2 should be added to the domain of the function t1 . To obtain the resulting value,
we use the inter-predicate according to the conventions explained in Section 4.2.
Example 8. The rule below shows how the application rule can be used to translate the successor of 1. The static part of the translation ensures that the interrelation for succ is interpreted correctly so that in any solution. The X gets
evaluated to 2.
(∅,∅), succ
(∅,∅), succ 1

∅, (succ, ∅)
(∅,∅), 1
∅, (1, ∅)
{domain(succ, 1)}, (X, inter((succ, 1), X))
10

Lambda
(E ∪(x, X),S ∪ bodydomain ), e
A, (t, B)
(E,S), λx. e
A ∪ ruleinter , ((l, scopeE ), S)
X =a new ASP variable
l =a new ASP constant
rule inter ={inter(((l, scopeE ), X), t) ← B}
body domain ={domain((l, scopeE ), X)}
Lambda expressions bring a new variable into scope, so they modify the (E, S)environment before recursively translating the body of the expression. The freshly
scoped variable needs to be put into the scoping function E, for this we assign
it a new ASP variable (X in the rule). This variable should have a finite range,
we invent a new name for our function (l in the rule) and use the domain predicate to restrict X to the domain of the function. The resulting translation (t, B)
represents the image of the function, so the rule rule inter is added to couple the
representation of the function to its interpretation.
Example 9. (∅, ∅)(λx.2) {inter(((l , ()), X), 2) ← domain ((l, ()), X)},((l, ()), ∅)
This can be read as follows: The translation of the constant function to 2 in an
empty environment is represented by the constant (l, ()). The interpretation of
(l, ()) when applied to any term X in the domain of (l, ()) is 2.
If zero-then-else
(E,S), eifz

Aifz , (tifz , Bifz )

(E, Bifz ∪ {tifz = 0}), ethen
(E, Bifz ∪ {tifz 6= 0}), eelse
(E,S), if eifz then ethen else eelse

Athen , (tthen , Bthen )
Aelse , (telse , Belse )
Aite ∪ ruleite , (X, S ∪ bodyite )

X =a new ASP variable
ite =a new ASP constant
rule ite ={inter((ite, scopeE ), tthen ) ← Bthen
, inter((ite, scopeE ), telse ) ← Belse }
body ite ={inter((ite, scopeE ), X)}
Aite =Aifz ∪ Athen ∪ Aelse
If zero expressions are translated using the translations of its three subexpressions. But we need to alter the safety to ensure that the “then”-part is only
evaluated if the “if”-part is 0 (and the analog for the “else” part). To construct
the value of the full expression we define an intermediate symbol (ite in the rule)
11

Listing 3 Translation of (λx. ifz x then succ else pred) 2 4
1
2
3
4
5
6
7

inter (( ite1 ,( X0 ) ) , succ ) : - domain (( l0 ,() ) , X0 ) , X0 =0.
inter (( ite1 ,( X0 ) ) , pred ) : - domain (( l0 ,() ) , X0 ) ,X0 < >0.
inter ((( l0 ,() ) , X0 ) , X1 ) : - domain (( l0 ,() ) , X0 ) , inter (( ite1 ,( X0 ) ) ,
X1 ) .
domain (( l0 ,() ) ,2) .
domain ( X2 ,4) : - inter ((( l0 ,() ) ,2) , X2 ) .
result ( X3 ) : - inter ((( l0 ,() ) ,2) , X2 ) , inter (( X2 ,4) , X3 ) .
% omitted static part visible in Listing 1

to represent the union of the “then” and the “else” part. Because the extra safety
(= 0, 6= 0) is mutually exclusive, only one of those terms will have a denotation,
so the interpretation of ite will be unique.
Example 10. The translation of (λx. ifz x then succ else pred) 2 4 is visible in Listing 3. The static part is omitted. Lines 1 and 2 are result of the if
zero-then-else translation. Line 3 is the result of the lambda translation. Lines 4
and 5 are the result of the application. And in line 6 the end result can be seen.
This rule can be read as follows: Let X2 be the application of the function to 2.
Let X3 be application of X2 to 4. The final result is X3.
4.5

Optimisations

The translation algorithm which is given in the previous section is not an optimal
translation. A lot of optimisations are possible, for instance, not all variables in
scope need to be present in scope E , only the ones which are actually used in the
subexpression. Applying such optimisations can significantly reduce the size of
the grounding of the ASP program. The possibilities here are very interesting
research topics, but are considered out of scope for this paper.
4.6

Implementation

An implementation was made in Kotlin. The runtime uses Clingo [9] to run the
resulting ASP files, but the resulting specifications could be used with any ASPCore-2 [2] compliant system. On https://dtai.cs.kuleuven.be/krr/pcf2asp
you can find a tool on which you can try out the translation. A few example
PCF formulas are provided, but you can ask for translations of arbitrary PCF
formulas and see their corresponding answer set.

5

Applications

5.1

Multiple interpretations for one variable

Directly translating PCF gives us little more than a traditional interpreter of
PCF would do, but based on this translation we can provide extra functionality, leveraging the existing ASP solvers. Traditional PCF does not support the
12

Listing 4 a + b = c in PCF
1
2
3
4
5
6

(λeq . λplus .
eq ( plus a b ) c )
( fix (λeq .λx .λy . ifz x then ( ifz y then 0 else 1)
else ( ifz y then 1 else eq ( pred x ) (
pred y ) ) ) )
( fix (λplus .λx .λy . ifz y then x else plus ( succ x ) ( pred y ) ) )

Listing 5 a + b = c in ASP
1
2
3
4
5
6
7

1{ a ( X ) }1 : - X =1..10.
1{ b ( X ) }1 : - X =1..10.
1{ c ( X ) }1 : - X =1..10.
: - not result (0) .
...
domain ( X1 , A ) : - domain (( l0 ,() ) , X0 ) , domain (( l1 ,( X0 ) ) , X1 ) ,a ( A ) .
...

possibility that the interpretation of a term is not uniquely defined, but we can
extend PCF so we can declare the variable a as a number between 1 and 10
without defining its specific value. In that case we can get (at most) 10 different
evaluations of our program, one for each interpretation of a. It is easy to extend
the translation to encode this in ASP.
Traditional interpreters solve the question: “What is the evaluation of this
program?”. But using these variables another question can be interesting: what
value(s) for a should I choose so that the program evaluates to 0. We can leverage
the strengths of ASP solvers to find the solutions. Expressing that the evaluation
should be zero can be done through a simple ASP constraint:
: - not result (0).
When this constraint is added, the resulting answer sets will now all have
the same interpretation (0) for the result predicate, but we are interested in the
interpretation for a.
Example 11. In Listing 4 you can see a PCF expression representing that a+b =
c. If we now use choice rules in ASP to translate these variables to the domain of
natural numbers between 0 and 10, we can use ASP to find multiple solutions of
this equation. An example of how this would look in ASP an be seen in Listing
5.
The problem in Example 11 can easily be generalised to arbitrarily complex
polynomials to model mixed integer problems. A graph coloring problem can be
represented by using a new constant for each node that needs to be colored and
writing down an expression that evaluated to 0 if the graph is colored correctly.
13

An important thing to note here is that ASP does not naively calculate the
result for all possible values of the choice rules. It uses a CDCL-based solving
algorithm to explore the search space in an intelligent way.
5.2

Towards a more expressive language

PCF is not intended to be an end-user language, but it serves as a basis for many
real world programming languages. Analogously, we are developing a more expressive language based on the principles of PCF. This language includes more
complex data types for representations which are more elegant than possible in
PCF. Together with the multiple-model semantics of ASP this leads to an interesting modelling language. Using these ideas the new Functional Modelling System (FMS) is being developed. On the website https://dtai.cs.kuleuven.be/krr/fms
a demonstration of this new system can be found. This system is an extension
of PCF with some more practical language constructs and uses the translation
principles described in this paper to use ASP as a solver engine for this new
language. However as indicated in Section 4.5, a lot of optimisations are needed
to be competitive with native ASP encodings. The efficiency of these translators
have not been formally investigated yet.

6

Conclusion

We presented a translation from PCF to ASP programs. A basic translation
is easily implemented, and many optimisations are possible. With only small
changes, we can exploit the search power of ASP to solve problems expressed in
PCF. This translation can serve as a basis to use functional programming techniques in modelling languages for search problems, or even tighter integrations
between functional and logical languages. FMS is under development now and
uses the techniques described in this paper as a basis for its language.

References
1. Gerhard Brewka, Thomas Eiter, and Miroslaw Truszczynski. Answer set programming at a glance. Commun. ACM, 54(12):92–103, 2011.
2. Francesco Calimeri, Wolfgang Faber, Martin Gebser, Giovambattista Ianni, Roland
Kaminski, Thomas Krennwallner, Nicola Leone, Francesco Ricca, and Torsten
Schaub. ASP-Core-2 input language format. Technical report, ASP Standardization Working Group, 2013.
3. Weidong Chen, Michael Kifer, and David S Warren. Hilog: A foundation for higherorder logic programming. The Journal of Logic Programming, 15(3):187–230, 1993.
4. Dominique Clément, Joëlle Despeyroux, Th. Despeyroux, and Gilles Kahn. A
simple applicative language: Mini-ml. In LISP and Functional Programming, pages
13–27, 1986.
5. Zaynah Dargaye and Xavier Leroy. Mechanized verification of CPS transformations. In Nachum Dershowitz and Andrei Voronkov, editors, Logic for Programming, Artificial Intelligence, and Reasoning, 14th International Conference, LPAR

14

2007, Yerevan, Armenia, October 15-19, 2007, Proceedings, volume 4790 of Lecture
Notes in Computer Science, pages 211–225. Springer, 2007.
6. Ingmar Dasseville, Matthias van der Hallen, Bart Bogaerts, Gerda Janssens, and
Marc Denecker. A compositional typed higher-order logic with definitions. In
Manuel Carro, Andy King, Marina De Vos, and Neda Saeedloei, editors, ICLP’16,
volume 52 of OASIcs, pages 14.1–14.14. Schloss Dagstuhl, November 2016.
7. Ingmar Dasseville, Matthias van der Hallen, Gerda Janssens, and Marc Denecker.
Semantics of templates in a compositional framework for building logics. TPLP,
15(4–5):681–695, 2015.
8. Gilles Dowek and Jean-Jacques Lévy. Introduction to the Theory of Programming
Languages. Undergraduate Topics in Computer Science. Springer, 2011.
9. Martin Gebser, Roland Kaminski, Benjamin Kaufmann, and Torsten Schaub.
Clingo = ASP + control: Preliminary report. CoRR, abs/1405.3694, 2014.
10. Danny Gratzer. A Tiny Compiler For A Typed Higher Order Language, 2015.
11. Giovambattista Ianni, Giuseppe Ielpa, Adriana Pietramala, Maria Carmela Santoro, and Francesco Calimeri. Enhancing answer set programming with templates.
In James P. Delgrande and Torsten Schaub, editors, 10th International Workshop
on Non-Monotonic Reasoning (NMR 2004), Whistler, Canada, June 6-8, 2004,
Proceedings, pages 233–239, 2004.
12. Benjamin Kaufmann, Nicola Leone, Simona Perri, and Torsten Schaub. Grounding
and solving in answer set programming. AI Magazine, 37(3):25–32, 2016.
13. Inderpal Singh Mumick, Sheldon J. Finkelstein, Hamid Pirahesh, and Raghu Ramakrishnan. Magic is relevant. In Hector Garcia-Molina and H. V. Jagadish,
editors, Proceedings of the 1990 ACM SIGMOD International Conference on Management of Data, Atlantic City, NJ, May 23-25, 1990., pages 247–258. ACM Press,
1990.
14. Ilkka Niemelä. Answer set programming: A declarative approach to solving search
problems. In Michael Fisher, Wiebe van der Hoek, Boris Konev, and Alexei Lisitsa,
editors, JELIA, volume 4160 of LNCS, pages 15–18. Springer, 2006. Invited talk.
15. Gordon D. Plotkin. LCF considered as a programming language. Theor. Comput.
Sci., 5(3):223–255, 1977.

15

