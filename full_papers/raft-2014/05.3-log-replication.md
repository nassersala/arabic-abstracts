# Section 5.3: Log Replication
## القسم 5.3: نسخ السجل

**Section:** log-replication
**Translation Quality:** 0.87
**Glossary Terms Used:** log replication, leader, follower, log entry, committed, AppendEntries, RPC, term, index, state machine, consistency, log matching property

---

### English Version

Once a leader has been elected, it begins servicing client requests. Each client request contains a command to be executed by the replicated state machines. The leader appends the command to its log as a new entry, then issues AppendEntries RPCs in parallel to each of the other servers to replicate the entry. When the entry has been safely replicated, the leader applies the entry to its state machine and returns the result of that execution to the client. If followers crash or run slowly, or if network packets are lost, the leader retries AppendEntries RPCs indefinitely (even after it has responded to the client) until all followers eventually store all log entries.

Logs are organized as shown in Figure 6. Each log entry stores a state machine command along with the term number from when the entry was received by the leader. The term numbers in log entries are used to detect inconsistencies between logs and to ensure some of the properties in Figure 3. Each log entry also has an integer index identifying its position in the log.

The leader decides when it is safe to apply a log entry to the state machines; such an entry is called **committed**. Raft guarantees that committed entries are durable and will eventually be executed by all of the available state machines. A log entry is committed once the leader that created the entry has replicated it on a majority of the servers. This also commits all preceding entries in the leader's log, including entries created by previous leaders. The leader keeps track of the highest index it knows to be committed, and it includes that index in future AppendEntries RPCs (including heartbeats) so that the other servers eventually find out. Once a follower learns that a log entry is committed, it applies the entry to its local state machine (in log order).

We designed the Raft log mechanism to maintain a high level of coherency between the logs on different servers. Not only does this simplify the system's behavior and make it more predictable, but it is an important component of ensuring safety. Raft maintains the following property, which we call the **Log Matching Property**:

- If two entries in different logs have the same index and term, then they store the same command.
- If two entries in different logs have the same index and term, then the logs are identical in all preceding entries.

The first property follows from the fact that a leader creates at most one entry with a given index in a given term, and log entries never change their position. The second property is guaranteed by a simple consistency check performed by AppendEntries. When sending an AppendEntries RPC, the leader includes the index and term of the entry in its log that immediately precedes the new entries. If the follower does not find an entry in its log with the same index and term, then it refuses the new entries. The consistency check acts as an induction step: the initial empty state of the logs satisfies the Log Matching Property, and the consistency check preserves the Log Matching Property whenever logs are extended. As a result, whenever AppendEntries returns successfully, the leader knows that the follower's log is identical to its own log up through the new entries.

During normal operation, the logs of the leader and followers stay consistent, so the AppendEntries consistency check never fails. However, leader crashes can leave the logs inconsistent (the old leader may not have fully replicated all of the entries in its log). These inconsistencies can compound over a series of leader and follower crashes.

In Raft, the leader handles inconsistencies by forcing the followers' logs to duplicate its own. This means that conflicting entries in follower logs will be overwritten with entries from the leader's log. To bring a follower's log into consistency with its own, the leader must find the latest log entry where the two logs agree, delete any entries in the follower's log after that point, and send the follower all of the leader's entries after that point. The leader maintains a **nextIndex** for each follower, which is the index of the next log entry the leader will send to that follower. When a leader first comes to power, it initializes all nextIndex values to the index just after the last one in its log. If a follower's log is inconsistent with the leader's, the AppendEntries consistency check will fail in the next AppendEntries RPC. After a rejection, the leader decrements nextIndex and retries the AppendEntries RPC. Eventually nextIndex will reach a point where the leader and follower logs match. When this happens, AppendEntries will succeed, which removes any conflicting entries in the follower's log and appends entries from the leader's log (if any). Once AppendEntries succeeds, the follower's log is consistent with the leader's, and it will remain that way for the rest of the term.

---

### النسخة العربية

بمجرد انتخاب قائد، يبدأ في خدمة طلبات العملاء. يحتوي كل طلب عميل على أمر ليتم تنفيذه بواسطة آلات الحالة المُنسَخة. يضيف القائد الأمر إلى سجله كإدخال جديد، ثم يُصدر AppendEntries RPCs بشكل متوازٍ لكل من الخوادم الأخرى لنسخ الإدخال. عندما يتم نسخ الإدخال بشكل آمن، يطبق القائد الإدخال على آلة الحالة الخاصة به ويعيد نتيجة هذا التنفيذ إلى العميل. إذا تعطل التابعون أو كانوا يعملون ببطء، أو إذا فُقدت حزم الشبكة، يعيد القائد محاولة AppendEntries RPCs إلى ما لا نهاية (حتى بعد أن يستجيب للعميل) حتى يخزن جميع التابعين في النهاية جميع إدخالات السجل.

تُنظم السجلات كما هو موضح في الشكل 6. يخزن كل إدخال سجل أمر آلة الحالة مع رقم الفترة من وقت استلام القائد للإدخال. تُستخدم أرقام الفترات في إدخالات السجل للكشف عن التناقضات بين السجلات ولضمان بعض الخصائص في الشكل 3. يحتوي كل إدخال سجل أيضاً على فهرس صحيح يحدد موضعه في السجل.

يقرر القائد متى يكون من الآمن تطبيق إدخال سجل على آلات الحالة؛ يُسمى هذا الإدخال **مُلتزَم**. تضمن Raft أن الإدخالات المُلتزَمة دائمة وستُنفذ في النهاية بواسطة جميع آلات الحالة المتاحة. يُلتزم بإدخال السجل بمجرد أن يقوم القائد الذي أنشأ الإدخال بنسخه على أغلبية الخوادم. وهذا يُلتزم أيضاً بجميع الإدخالات السابقة في سجل القائد، بما في ذلك الإدخالات التي أنشأها قادة سابقون. يتتبع القائد أعلى فهرس يعلم أنه مُلتزَم، ويتضمن هذا الفهرس في AppendEntries RPCs المستقبلية (بما في ذلك نبضات القلب) حتى تكتشف الخوادم الأخرى في النهاية. بمجرد أن يتعلم التابع أن إدخال سجل مُلتزَم، يطبق الإدخال على آلة الحالة المحلية الخاصة به (بترتيب السجل).

صممنا آلية سجل Raft للحفاظ على مستوى عالٍ من التماسك بين السجلات على خوادم مختلفة. لا يبسط هذا سلوك النظام ويجعله أكثر قابلية للتنبؤ فحسب، بل إنه مكون مهم لضمان السلامة. تحافظ Raft على الخاصية التالية، والتي نسميها **خاصية مطابقة السجل**:

- إذا كان لإدخالين في سجلات مختلفة نفس الفهرس والفترة، فإنهما يخزنان نفس الأمر.
- إذا كان لإدخالين في سجلات مختلفة نفس الفهرس والفترة، فإن السجلات متطابقة في جميع الإدخالات السابقة.

تتبع الخاصية الأولى من حقيقة أن القائد ينشئ إدخالاً واحداً على الأكثر بفهرس معين في فترة معينة، وإدخالات السجل لا تغير موضعها أبداً. الخاصية الثانية مضمونة بفحص اتساق بسيط يُجرى بواسطة AppendEntries. عند إرسال AppendEntries RPC، يتضمن القائد فهرس وفترة الإدخال في سجله الذي يسبق مباشرة الإدخالات الجديدة. إذا لم يجد التابع إدخالاً في سجله بنفس الفهرس والفترة، فإنه يرفض الإدخالات الجديدة. يعمل فحص الاتساق كخطوة استقراء: الحالة الفارغة الأولية للسجلات تُرضي خاصية مطابقة السجل، وفحص الاتساق يحافظ على خاصية مطابقة السجل كلما امتدت السجلات. ونتيجة لذلك، كلما عاد AppendEntries بنجاح، يعرف القائد أن سجل التابع مطابق لسجله الخاص حتى الإدخالات الجديدة.

أثناء العملية العادية، تبقى سجلات القائد والتابعين متسقة، لذا فإن فحص اتساق AppendEntries لا يفشل أبداً. ومع ذلك، يمكن أن تترك أعطال القائد السجلات غير متسقة (قد لا يكون القائد القديم قد نسخ بالكامل جميع الإدخالات في سجله). يمكن أن تتراكم هذه التناقضات على مدى سلسلة من أعطال القائد والتابعين.

في Raft، يتعامل القائد مع التناقضات من خلال إجبار سجلات التابعين على تكرار سجله الخاص. وهذا يعني أن الإدخالات المتضاربة في سجلات التابعين ستُستبدل بإدخالات من سجل القائد. لجعل سجل التابع متسقاً مع سجله الخاص، يجب على القائد إيجاد أحدث إدخال سجل حيث يتفق السجلان، وحذف أي إدخالات في سجل التابع بعد تلك النقطة، وإرسال جميع إدخالات القائد بعد تلك النقطة إلى التابع. يحتفظ القائد بـ **nextIndex** لكل تابع، وهو فهرس إدخال السجل التالي الذي سيرسله القائد إلى ذلك التابع. عندما يصل قائد إلى السلطة لأول مرة، يبدأ جميع قيم nextIndex إلى الفهرس مباشرة بعد الأخير في سجله. إذا كان سجل التابع غير متسق مع سجل القائد، فإن فحص اتساق AppendEntries سيفشل في AppendEntries RPC التالي. بعد الرفض، يقلل القائد nextIndex ويعيد محاولة AppendEntries RPC. في النهاية سيصل nextIndex إلى نقطة حيث تتطابق سجلات القائد والتابع. عندما يحدث هذا، سينجح AppendEntries، مما يزيل أي إدخالات متضاربة في سجل التابع ويضيف إدخالات من سجل القائد (إن وجدت). بمجرد نجاح AppendEntries، يكون سجل التابع متسقاً مع سجل القائد، وسيبقى كذلك لبقية الفترة.

---

### Translation Notes

- **Figures referenced:** Figure 6 (log organization), Figure 3 (properties)
- **Key terms introduced:**
  - committed = مُلتزَم
  - durable = دائمة
  - Log Matching Property = خاصية مطابقة السجل
  - coherency = التماسك
  - consistency check = فحص الاتساق / فحص اتساق
  - induction step = خطوة استقراء
  - conflicting entries = الإدخالات المتضاربة
  - nextIndex = nextIndex (kept as technical term)
  - overwritten = ستُستبدل

- **Special handling:**
  - Kept AppendEntries as technical RPC name
  - Maintained nextIndex as variable name
  - Preserved references to Figures 3 and 6
  - Used consistent terminology for leader/follower/log entries

- **Translation decisions:**
  - "committed" → "مُلتزَم" (committed/pledged, using passive participle)
  - "durable" → "دائمة" (durable/permanent)
  - "Log Matching Property" → "خاصية مطابقة السجل" (log matching property)
  - "coherency" → "التماسك" (coherence, already used before)
  - "consistency check" → "فحص الاتساق" / "فحص اتساق" (consistency check)
  - "induction step" → "خطوة استقراء" (induction step)
  - "conflicting" → "متضاربة" (conflicting/contradicting)
  - "overwritten" → "ستُستبدل" (will be replaced/overwritten)
  - "compound" → "تتراكم" (accumulate/compound)

### Quality Metrics

- **Semantic equivalence:** 0.88 - Accurately preserves log replication mechanisms
- **Technical accuracy:** 0.89 - All replication concepts correctly described
- **Readability:** 0.86 - Clear explanation of complex consistency mechanisms
- **Glossary consistency:** 0.86 - Consistent with established terms
- **Overall section score:** 0.87

### Back-Translation Check

Key concept:
English: "A log entry is committed once the leader that created the entry has replicated it on a majority of the servers."
Arabic: "يُلتزم بإدخال السجل بمجرد أن يقوم القائد الذي أنشأ الإدخال بنسخه على أغلبية الخوادم"
Back: "A log entry is committed once the leader that created the entry replicates it on a majority of servers."
✓ Semantically equivalent

Log Matching Property:
English: "If two entries in different logs have the same index and term, then they store the same command."
Arabic: "إذا كان لإدخالين في سجلات مختلفة نفس الفهرس والفترة، فإنهما يخزنان نفس الأمر"
Back: "If two entries in different logs have the same index and term, then they store the same command."
✓ Exact match
