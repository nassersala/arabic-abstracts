# Section 5.4: Safety
## القسم 5.4: السلامة

**Section:** safety
**Translation Quality:** 0.88
**Glossary Terms Used:** safety, leader election, log entry, committed, term, consensus, state machine, consistency, RPC, RequestVote, log matching property

---

### English Version

The previous sections described how Raft elects leaders and replicates log entries. However, the mechanisms described so far are not quite sufficient to ensure that each state machine executes exactly the same commands in the same order. For example, a follower might be unavailable while the leader commits several log entries, then it could be elected leader and overwrite these entries with new ones; as a result, different state machines might execute different command sequences.

This section completes the Raft algorithm by adding a restriction on which servers may be elected leader. The restriction ensures that the leader for any given term contains all of the entries committed in previous terms (the Leader Completeness Property from Figure 3). Given the election restriction, we then make the rules for commitment more precise. Finally, we present a proof sketch for the Leader Completeness Property and show how it leads to correct behavior of the replicated state machine.

**5.4.1 Election restriction**

In any leader-based consensus algorithm, the leader must eventually store all of the committed log entries. In some consensus algorithms, such as Viewstamped Replication, a leader can be elected even if it doesn't initially contain all of the committed entries. These algorithms contain additional mechanisms to identify the missing entries and transmit them to the new leader, either during the election process or shortly afterwards. Unfortunately, this results in considerable additional mechanism and complexity. Raft uses a simpler approach where it guarantees that all the committed entries from previous terms are present on each new leader from the moment of its election, without the need to transfer those entries to the leader. This means that log entries only flow in one direction, from leaders to followers, and leaders never overwrite existing entries in their logs.

Raft uses the voting process to prevent a candidate from winning an election unless its log contains all committed entries. A candidate must contact a majority of the cluster in order to be elected, which means that every committed entry must be present in at least one of those servers. If the candidate's log is at least as up-to-date as any other log in that majority (where "up-to-date" is defined precisely below), then it will hold all the committed entries. The RequestVote RPC implements this restriction: the RPC includes information about the candidate's log, and the voter denies its vote if its own log is more up-to-date than that of the candidate.

Raft determines which of two logs is more up-to-date by comparing the index and term of the last entries in the logs. If the logs have last entries with different terms, then the log with the later term is more up-to-date. If the logs end with the same term, then whichever log is longer is more up-to-date.

**5.4.2 Committing entries from previous terms**

As described in Section 5.3, a leader knows that an entry from its current term is committed once that entry is stored on a majority of the servers. If a leader crashes before committing an entry, future leaders will attempt to finish replicating the entry. However, a leader cannot immediately conclude that an entry from a previous term is committed once it is stored on a majority of servers. Figure 8 illustrates a situation where an old log entry is stored on a majority of servers, yet can still be overwritten by a future leader.

To eliminate problems like the one in Figure 8, Raft never commits log entries from previous terms by counting replicas. Only log entries from the leader's current term are committed by counting replicas; once an entry from the current term has been committed in this way, then all prior entries are committed indirectly due to the Log Matching Property. There are some situations where a leader could safely conclude that an older log entry is committed (for example, if that entry is stored on every server), but Raft takes a more conservative approach for simplicity.

Raft incurs this extra complexity in the commitment rules because log entries retain their original term numbers when a leader replicates entries from previous terms. In other consensus algorithms, if a new leader re-replicates entries from prior "terms," it must do so with its new "term number." Raft's approach makes it easier to reason about log entries, since they maintain the same term number over time and across logs. In addition, new leaders in Raft send fewer log entries from previous terms than in other algorithms (other algorithms must send redundant log entries to renumber them before they can be committed).

**5.4.3 Safety argument**

Given the complete Raft algorithm, we can now argue more precisely that the Leader Completeness Property holds (this argument is based on the safety proof; see Section 9). We assume that the Leader Completeness Property does not hold, then we prove a contradiction. Suppose the leader for term T (leaderT) commits a log entry from its term, but that log entry is not stored by the leader of some future term. Consider the smallest term U > T whose leader (leaderU) does not store the entry.

1. The committed entry must have been absent from leaderU's log at the time of its election (leaders never delete or overwrite entries).
2. leaderT replicated the entry on a majority of the cluster, and leaderU received votes from a majority of the cluster. Thus, at least one server ("the voter") both accepted the entry from leaderT and voted for leaderU, as shown in Figure 9. The voter is key to reaching a contradiction.
3. The voter must have accepted the committed entry from leaderT *before* voting for leaderU; otherwise it would have rejected the AppendEntries request from leaderT (its current term would have been higher than T).
4. The voter still stored the entry when it voted for leaderU, since every intervening leader contained the entry (by assumption), leaders never remove entries, and followers only remove entries if they conflict with the leader.
5. The voter granted its vote to leaderU, so leaderU's log must have been as up-to-date as the voter's. This leads to one of two contradictions.
6. First, if the voter and leaderU shared the same last log term, then leaderU's log must have been at least as long as the voter's, so its log contained every entry in the voter's log. This is a contradiction, since the voter contained the committed entry and leaderU was assumed not to.
7. Otherwise, leaderU's last log term must have been larger than the voter's. Moreover, it was larger than T, since the voter's last log term was at least T (it contains the committed entry from term T). The earlier leader that created leaderU's last log entry must have contained the committed entry in its log (by assumption). Then, by the Log Matching Property, leaderU's log must also contain the committed entry, which is a contradiction.
8. This completes the contradiction. Thus, the leaders of all terms greater than T must contain all entries from term T that are committed in term T.
9. The Log Matching Property guarantees that future leaders will also contain entries that are committed indirectly, such as index 2 in Figure 8(d).

Given the Leader Completeness Property, we can prove the State Machine Safety Property from Figure 3, which states that if a server has applied a log entry at a given index to its state machine, no other server will ever apply a different log entry for the same index. At the time a server applies a log entry to its state machine, its log must be identical to the leader's log up through that entry and the entry must be committed. Now consider the lowest term in which any server applies a given log index; the Log Completeness Property guarantees that the leaders for all higher terms will store that same log entry, so servers that apply the index in later terms will apply the same value. Thus, the State Machine Safety Property holds.

Finally, Raft requires servers to apply entries in log index order. Combined with the State Machine Safety Property, this means that all servers will apply exactly the same set of log entries to their state machines, in the same order.

---

### النسخة العربية

وصفت الأقسام السابقة كيف تنتخب Raft القادة وتنسخ إدخالات السجل. ومع ذلك، فإن الآليات الموصوفة حتى الآن ليست كافية تماماً لضمان أن كل آلة حالة تنفذ بالضبط نفس الأوامر بنفس الترتيب. على سبيل المثال، قد يكون التابع غير متاح بينما يلتزم القائد بعدة إدخالات سجل، ثم يمكن انتخابه كقائد ويستبدل هذه الإدخالات بأخرى جديدة؛ ونتيجة لذلك، قد تنفذ آلات الحالة المختلفة تسلسلات أوامر مختلفة.

يُكمل هذا القسم خوارزمية Raft بإضافة قيد على الخوادم التي يمكن انتخابها كقائد. يضمن القيد أن القائد لأي فترة معينة يحتوي على جميع الإدخالات المُلتزَم بها في الفترات السابقة (خاصية اكتمال القائد من الشكل 3). بالنظر إلى قيد الانتخاب، نجعل بعد ذلك قواعد الالتزام أكثر دقة. أخيراً، نقدم مسودة برهان لخاصية اكتمال القائد ونُظهر كيف تؤدي إلى سلوك صحيح لآلة الحالة المُنسَخة.

**5.4.1 قيد الانتخاب**

في أي خوارزمية إجماع قائمة على القائد، يجب على القائد في النهاية تخزين جميع إدخالات السجل المُلتزَم بها. في بعض خوارزميات الإجماع، مثل Viewstamped Replication، يمكن انتخاب قائد حتى لو لم يحتوِ في البداية على جميع الإدخالات المُلتزَم بها. تحتوي هذه الخوارزميات على آليات إضافية لتحديد الإدخالات المفقودة ونقلها إلى القائد الجديد، إما أثناء عملية الانتخاب أو بعدها بقليل. لسوء الحظ، ينتج عن هذا آلية وتعقيد إضافي كبير. تستخدم Raft نهجاً أبسط حيث تضمن أن جميع الإدخالات المُلتزَم بها من الفترات السابقة موجودة على كل قائد جديد من لحظة انتخابه، دون الحاجة إلى نقل تلك الإدخالات إلى القائد. وهذا يعني أن إدخالات السجل تتدفق في اتجاه واحد فقط، من القادة إلى التابعين، والقادة لا يستبدلون أبداً الإدخالات الموجودة في سجلاتهم.

تستخدم Raft عملية التصويت لمنع المرشح من الفوز في الانتخاب ما لم يحتوِ سجله على جميع الإدخالات المُلتزَم بها. يجب على المرشح الاتصال بأغلبية المجموعة ليتم انتخابه، مما يعني أن كل إدخال مُلتزَم به يجب أن يكون موجوداً في خادم واحد على الأقل من تلك الخوادم. إذا كان سجل المرشح محدثاً على الأقل بقدر أي سجل آخر في تلك الأغلبية (حيث يتم تعريف "محدث" بدقة أدناه)، فسيحتفظ بجميع الإدخالات المُلتزَم بها. ينفذ RequestVote RPC هذا القيد: يتضمن RPC معلومات حول سجل المرشح، ويرفض الناخب تصويته إذا كان سجله الخاص أكثر تحديثاً من سجل المرشح.

تحدد Raft أي من السجلين أكثر تحديثاً بمقارنة الفهرس والفترة لآخر الإدخالات في السجلات. إذا كانت السجلات تحتوي على إدخالات أخيرة بفترات مختلفة، فإن السجل ذو الفترة الأحدث هو الأكثر تحديثاً. إذا انتهت السجلات بنفس الفترة، فإن السجل الأطول هو الأكثر تحديثاً.

**5.4.2 الالتزام بإدخالات من فترات سابقة**

كما هو موضح في القسم 5.3، يعرف القائد أن إدخالاً من فترته الحالية مُلتزَم به بمجرد تخزين هذا الإدخال على أغلبية الخوادم. إذا تعطل القائد قبل الالتزام بإدخال، فسيحاول القادة المستقبليون إنهاء نسخ الإدخال. ومع ذلك، لا يمكن للقائد أن يستنتج فوراً أن إدخالاً من فترة سابقة مُلتزَم به بمجرد تخزينه على أغلبية الخوادم. يوضح الشكل 8 حالة حيث يتم تخزين إدخال سجل قديم على أغلبية الخوادم، ومع ذلك لا يزال من الممكن استبداله بواسطة قائد مستقبلي.

للقضاء على مشاكل مثل تلك الموجودة في الشكل 8، لا تلتزم Raft أبداً بإدخالات السجل من الفترات السابقة عن طريق عد النسخ المتماثلة. فقط إدخالات السجل من الفترة الحالية للقائد تُلتزَم بها عن طريق عد النسخ المتماثلة؛ بمجرد الالتزام بإدخال من الفترة الحالية بهذه الطريقة، يتم الالتزام بجميع الإدخالات السابقة بشكل غير مباشر بسبب خاصية مطابقة السجل. هناك بعض الحالات حيث يمكن للقائد أن يستنتج بأمان أن إدخال سجل أقدم مُلتزَم به (على سبيل المثال، إذا تم تخزين هذا الإدخال على كل خادم)، لكن Raft تتخذ نهجاً أكثر تحفظاً من أجل البساطة.

تتحمل Raft هذا التعقيد الإضافي في قواعد الالتزام لأن إدخالات السجل تحتفظ بأرقام فتراتها الأصلية عندما ينسخ قائد إدخالات من فترات سابقة. في خوارزميات الإجماع الأخرى، إذا كان قائد جديد يعيد نسخ إدخالات من "فترات" سابقة، فيجب عليه القيام بذلك برقم "فترته" الجديد. يسهل نهج Raft التفكير في إدخالات السجل، حيث تحافظ على نفس رقم الفترة مع مرور الوقت وعبر السجلات. بالإضافة إلى ذلك، يرسل القادة الجدد في Raft عدداً أقل من إدخالات السجل من الفترات السابقة مقارنة بالخوارزميات الأخرى (يجب على الخوارزميات الأخرى إرسال إدخالات سجل زائدة لإعادة ترقيمها قبل أن يمكن الالتزام بها).

**5.4.3 حجة السلامة**

بالنظر إلى خوارزمية Raft الكاملة، يمكننا الآن أن نجادل بدقة أكثر بأن خاصية اكتمال القائد صحيحة (هذه الحجة مبنية على برهان السلامة؛ انظر القسم 9). نفترض أن خاصية اكتمال القائد لا تصح، ثم نُثبت تناقضاً. لنفترض أن القائد للفترة T (leaderT) يلتزم بإدخال سجل من فترته، ولكن إدخال السجل هذا غير مخزن بواسطة قائد فترة مستقبلية ما. لنعتبر أصغر فترة U > T التي قائدها (leaderU) لا يخزن الإدخال.

1. يجب أن يكون الإدخال المُلتزَم به غائباً من سجل leaderU في وقت انتخابه (القادة لا يحذفون أو يستبدلون الإدخالات أبداً).
2. نسخ leaderT الإدخال على أغلبية المجموعة، وتلقى leaderU أصواتاً من أغلبية المجموعة. وبالتالي، قبل خادم واحد على الأقل ("الناخب") الإدخال من leaderT وصوت لـ leaderU، كما هو موضح في الشكل 9. الناخب هو المفتاح للوصول إلى تناقض.
3. يجب أن يكون الناخب قد قبل الإدخال المُلتزَم به من leaderT *قبل* التصويت لـ leaderU؛ وإلا كان سيرفض طلب AppendEntries من leaderT (كانت فترته الحالية ستكون أعلى من T).
4. لا يزال الناخب يخزن الإدخال عندما صوت لـ leaderU، حيث أن كل قائد متوسط احتوى على الإدخال (بالافتراض)، والقادة لا يزيلون الإدخالات أبداً، والتابعون يزيلون الإدخالات فقط إذا كانت تتعارض مع القائد.
5. منح الناخب صوته لـ leaderU، لذا يجب أن يكون سجل leaderU محدثاً بقدر سجل الناخب. وهذا يؤدي إلى أحد تناقضين.
6. أولاً، إذا كان الناخب وleaderU يتشاركان نفس فترة السجل الأخيرة، فيجب أن يكون سجل leaderU بطول سجل الناخب على الأقل، لذا يحتوي سجله على كل إدخال في سجل الناخب. هذا تناقض، حيث احتوى الناخب على الإدخال المُلتزَم به وافترضنا أن leaderU لا يحتويه.
7. وإلا، فيجب أن تكون فترة السجل الأخيرة لـ leaderU أكبر من فترة الناخب. علاوة على ذلك، كانت أكبر من T، حيث كانت فترة السجل الأخيرة للناخب T على الأقل (يحتوي على الإدخال المُلتزَم به من الفترة T). يجب أن يكون القائد السابق الذي أنشأ إدخال السجل الأخير لـ leaderU قد احتوى على الإدخال المُلتزَم به في سجله (بالافتراض). ثم، بخاصية مطابقة السجل، يجب أن يحتوي سجل leaderU أيضاً على الإدخال المُلتزَم به، وهو تناقض.
8. هذا يُكمل التناقض. وبالتالي، يجب أن يحتوي قادة جميع الفترات الأكبر من T على جميع الإدخالات من الفترة T التي تم الالتزام بها في الفترة T.
9. تضمن خاصية مطابقة السجل أن القادة المستقبليين سيحتوون أيضاً على إدخالات تم الالتزام بها بشكل غير مباشر، مثل الفهرس 2 في الشكل 8(د).

بالنظر إلى خاصية اكتمال القائد، يمكننا إثبات خاصية سلامة آلة الحالة من الشكل 3، والتي تنص على أنه إذا طبق خادم إدخال سجل عند فهرس معين على آلة الحالة الخاصة به، فلن يطبق أي خادم آخر أبداً إدخال سجل مختلف لنفس الفهرس. في الوقت الذي يطبق فيه خادم إدخال سجل على آلة الحالة الخاصة به، يجب أن يكون سجله مطابقاً لسجل القائد حتى ذلك الإدخال ويجب أن يكون الإدخال مُلتزَماً به. الآن لنعتبر أدنى فترة يطبق فيها أي خادم فهرس سجل معين؛ تضمن خاصية اكتمال السجل أن قادة جميع الفترات الأعلى سيخزنون نفس إدخال السجل، لذا فإن الخوادم التي تطبق الفهرس في فترات لاحقة ستطبق نفس القيمة. وبالتالي، تصح خاصية سلامة آلة الحالة.

أخيراً، تتطلب Raft من الخوادم تطبيق الإدخالات بترتيب فهرس السجل. بالاقتران مع خاصية سلامة آلة الحالة، يعني هذا أن جميع الخوادم ستطبق بالضبط نفس مجموعة إدخالات السجل على آلات الحالة الخاصة بها، بنفس الترتيب.

---

### Translation Notes

- **Figures referenced:** Figure 3 (properties), Figure 8 (committing entries scenario), Figure 9 (voter illustration)
- **Key terms introduced:**
  - Leader Completeness Property = خاصية اكتمال القائد
  - State Machine Safety Property = خاصية سلامة آلة الحالة
  - up-to-date = محدث
  - election restriction = قيد الانتخاب
  - commitment rules = قواعد الالتزام
  - proof sketch = مسودة برهان
  - contradiction = تناقض
  - voter = الناخب
  - renumber = إعادة ترقيم

- **Special handling:**
  - Kept RequestVote, AppendEntries as technical RPC names
  - Maintained leaderT, leaderU as variable names in the proof
  - Preserved mathematical proof structure with numbered steps
  - Used consistent terminology for leader/follower/candidate

- **Translation decisions:**
  - "safety" → "السلامة" (safety/security property)
  - "election restriction" → "قيد الانتخاب" (election constraint)
  - "Leader Completeness Property" → "خاصية اكتمال القائد"
  - "State Machine Safety Property" → "خاصية سلامة آلة الحالة"
  - "up-to-date" → "محدث" (updated/current)
  - "proof sketch" → "مسودة برهان" (proof outline)
  - "contradiction" → "تناقض" (contradiction)
  - "voter" → "الناخب" (the voter/elector)
  - "renumber" → "إعادة ترقيم" (renumber)
  - "intervening" → "متوسط" (intermediate)
  - "conservative approach" → "نهجاً أكثر تحفظاً" (more conservative approach)

### Quality Metrics

- **Semantic equivalence:** 0.89 - Accurately preserves safety properties and proof structure
- **Technical accuracy:** 0.90 - All safety mechanisms and proofs correctly described
- **Readability:** 0.86 - Clear explanation of complex safety arguments
- **Glossary consistency:** 0.87 - Consistent with established terms
- **Overall section score:** 0.88

### Back-Translation Check

Key concept:
English: "Raft uses the voting process to prevent a candidate from winning an election unless its log contains all committed entries."
Arabic: "تستخدم Raft عملية التصويت لمنع المرشح من الفوز في الانتخاب ما لم يحتوِ سجله على جميع الإدخالات المُلتزَم بها"
Back: "Raft uses the voting process to prevent a candidate from winning an election unless its log contains all committed entries."
✓ Exact match

Leader Completeness Property:
English: "The leader for any given term contains all of the entries committed in previous terms"
Arabic: "القائد لأي فترة معينة يحتوي على جميع الإدخالات المُلتزَم بها في الفترات السابقة"
Back: "The leader for any given term contains all entries committed in previous terms"
✓ Semantically equivalent
