# Section 2: Proposed Framework
## القسم 2: إطار العمل المقترح

**Section:** proposed-framework
**Translation Quality:** 0.87
**Glossary Terms Used:** framework, formal methods, property-based testing, formal model, formal verification, specification, system

---

### English Version

Figure 1 depicts the proposed framework that will allow for combining FMs with PBT. The general idea is to start with specifying the system using human-oriented modelling techniques based on FMs. After the specification phase, the software of the system under test is designed according to the specification. The framework will then generate random test cases to exercise and verify that the system runs according to the specification. If a test fails, it will be the judgment of the engineer to decide whether the errors were in the system software or in the specification formulas for which the system was not correctly specified. If the test passes without any errors, the system under test meets the specification.

The FM specification gets translated to host programming language (Scala in this case). These specification gets formal verification depending on the flavour of FM being used. For example, in case of TLA+, the TLA+ model checker (TLC) is used to check the specification. On the other hand, in case of FOCUSST, the theorem prover Isabelle/HOL via the framework Focus on Isabelle is used to verify systems specification, cf. (Nipkow et al., 2002) and (Spichkova, 2007).

The workflow within the proposed framework includes the following steps:

• To create an (informal) requirements specification of the system;
• To transform the informal specification to a formal specification (model) of the system, using TLA+ or FOCUSST;
• To verify formal model, using TLA+ model checker or Isabelle/HOL theorem prover, respectively;
• To translate the formal model to Scala using the provided translation schema;
• To add the specified in Scala model to the extended ScalaCheck library;
• To check the extended ScalaCheck library against the behaviour generated by FM specification.

In this section, we show the applicability of the proposed framework to TLA+ and FOCUSST. The goal is to demonstrate how the proposed framework can be applied to many types of FMs with similar syntax. Each subsection presents systematic informal program transformation schemas. Using these schemas makes transforming FM formulas to any hosting language, Scala in this case, an easy mechanical task. We start by analysing TLA+ syntax and semantics. After that, we show the design and model the API for the TLA+ flavour. After that, we show the designed API and the testing it using small example (One Bit Block). Similar process applied to FOCUSST, showing the analysis of FOCUSST syntax and semantics. Restricting FOCUSST to it's major parts that is related to temporal properties.

**Figure 1: Proposed Framework**
[Framework diagram showing: Formal Methods with Timing Aspects box containing Specification and Properties, with Formal Verification and Formal Transformation arrows. Below that, Scala program with API calls, State Models, BeSpaceD, leading to Property based testing and Test Cases in Scala based on properties]

## 2.1 Application to TLA+

TLA provides a toolbox which includes an integrated development environment (IDE) for the TLA+. The IDE allows create and edit specifications, it also shows parsing errors and can be used to turn TLA+ model checker. To decrease the cognitive load of the developer and tester, it also includes an error trace viewer and explorer: these components provide a structured view of the states, illustrate how the states/values are changed at each step, and allow to run the TLA+ proof system.

A TLA formula such as Init ∧ [Next]v specifies the initial states and the allowed transitions of a system. It allows for transitions that do not change the value of v. This kind of transitions is called stuttering transitions. Most TLA system specifications are of the form Init ∧ [Next]v ∧L. The semantics of such formulas are shown in Table 1. Table 2 shows logic operators in TLA+ and their mappings in Scala, many of the logical operators in Scala are provided by BeSpaceD.

**Table 1: Semantics of TLA formula**
| Term | Description |
|------|-------------|
| Init | State formula describing the initial state(s) |
| Next | Action formula formalizing the transition relation – usually a disjunction A1∨..∨An of possible actions (events) Ai |
| L | Temporal formula asserting liveness conditions |

**Table 2: Operator mapping from TLA+ to Scala**
| TLA+ | Scala |
|------|-------|
| /\ | AND |
| \/ | OR |
| ⇒ | IMPLIES |
| TRUE | TRUE |
| FALSE | FALSE |
| BOOLEAN | Boolean |
| {TRUE,FALSE} | List(TRUE, FALSE) |
| ≤ | lessThanEq |
| ≥ | greaterThanEq |
| > | greaterThan |
| < | lessThan |
| ≰ | lessThanEqNot |
| ≮ | lessThanNot |
| ≱ | greaterThanEqNot |
| ≯ | greaterThanNot |
| ∈ | IN |
| x == e | defined(x, e) |
| x = e | assign(x, e) |
| ∀x ∈ S : p | for {x ← S; if p} yield x |
| ∃x ∈ S : p | exists(x, S, p) |
| CHOOSE x ∈ S | choose(x, List(S)) |

In TLA+, a representation of an abstraction of a system is modelled using the standard model. The Standard Model states that an abstract system is described as a collection of behaviours, each representing a possible execution of the system, where a behaviour is a sequence of states and a state is an assignment of values to variables. In this model, an event (step) is the transition from one state to the next in a behaviour. For example, In one-bit clock, formulas are defined as follows:

```
VARIABLE b
Init == (b = 0) \/ (b = 1)
Next == \/ /\ b = 0
           /\ b' = 1
        \/ /\ b = 1
           /\ b' = 0
```

These two TLA+ statements define Init and Next to be two formulas. Therefore, referencing init or Next is completely equivalent to typing ((b = 0) \/ (b = 1)). The equality symbol = (typed ==) is read is defined to equal. To transform these formulas into a host programming language, it is necessary to capture the essential aspects of the formula to be transformed, i.e., to create a translation schema. Each transformation step will consist of two elements: one to capture the TLA+ formula and one to capture the corresponding programming language function. The two schemata together can then be used to do the transformation.

The TLA+ elements for the above formulas:
```
f1 == p \/ q
f2 == \/ /\ p
         /\ q
      \/ /\ q
         /\ p
```

That is, f1 represent Init, f2 represent Next, p represent (b=0), q represent (b=1) respectively. According to the translation schema, the translation of one bit clock from TLA+ to Scala is as follows:

```scala
val b: TLAVariable = TLAVariable(IN(List(0, 1)))
val init: TLAInit = OR(defined(b,0), defined(b,1))
val next: TLANext = {
  while(true) {
    if defined(b, 0)
      return assign(b, 1)
    else
      return assign(b, 0)
  }
}
```

## 2.2 Application to FOCUSST

The FOCUSST language was inspired by Focus, a framework for formal specification and development of interactive systems. In both languages, specifications are based on the notion of streams, cf. (Broy and Stølen, 2001). The syntax of FOCUSST is particularly devoted to specify spatial (S) and timing (T) aspects in a comprehensible fashion, which is the reason to extend the name of the language by ST: FOCUSST stream is a mapping from natural numbers to lists of messages within the corresponding time intervals. Table 3 shows a partial mappings between FOCUSST basic operators and their Scala representations.

**Table 3: Operator mapping from FOCUSST to Scala**
| FOCUSST | Scala |
|---------|-------|
| /\ | AND |
| \/ | OR |
| → | IMPLIES |
| TRUE | TRUE |
| FALSE | FALSE |
| BOOLEAN | Boolean |
| ≤ | lessThanEq |
| ≥ | greaterThanEq |
| > | greaterThan |
| < | lessThan |
| ≰ | lessThanEqNot |
| ≮ | lessThanNot |
| ≱ | greaterThanEqNot |
| ≯ | greaterThanNot |
| ∈ | IN |
| x == e | defined(x, e) |
| x = e | assign(x, e) |
| ∀x ∈ S : p | for {x ← S; if p} yield x |
| ∃x ∈ S : p | exists(x, S, p) |
| ⟨⟩ | List() |
| ⟨a1,...,am⟩ | a1 to am |

**Figure 2: FOCUSST Specification of Steam Boiler Controller** (Spichkova, 2016)
[Specification showing Controller module with input/output streams, local variables, assumptions, and guarantees for water level control]

The FOCUSST specification layout is based on human factor analysis within formal methods (Spichkova, 2012; Spichkova, 2013). Figure 2 provides an example on how a FOCUSST specification looks like. The in and out sections of FOCUSST specifications are used to specify input and output streams of the corresponding types. local and init sections include local variables and initial values, respectively. FOCUSST requires using assumption-guarantee templates, to avoid the omission of unnecessary assumptions about the system's environment. The keyword asm lists the assumption that the specified component expect from its environment, e.g., the assumption ts(s) would mean that the input stream s should contain exactly one message per time interval. The component behaviour that should be guaranteed in the case all assumptions are fulfilled, is then described in the specification section gar.

---

### النسخة العربية

يصور الشكل 1 إطار العمل المقترح الذي سيسمح بدمج الأساليب الرسمية مع الاختبار القائم على الخصائص. الفكرة العامة هي البدء بتحديد مواصفات النظام باستخدام تقنيات النمذجة الموجهة نحو الإنسان القائمة على الأساليب الرسمية. بعد مرحلة التحديد، يتم تصميم برمجيات النظام قيد الاختبار وفقاً للمواصفات. سيقوم إطار العمل بعد ذلك بتوليد حالات اختبار عشوائية لممارسة والتحقق من أن النظام يعمل وفقاً للمواصفات. إذا فشل الاختبار، سيكون الحكم من المهندس لتقرير ما إذا كانت الأخطاء في برمجيات النظام أو في صيغ المواصفات التي لم يتم تحديد النظام لها بشكل صحيح. إذا اجتاز الاختبار دون أي أخطاء، فإن النظام قيد الاختبار يلبي المواصفات.

يتم ترجمة مواصفات الأسلوب الرسمي إلى لغة البرمجة المضيفة (Scala في هذه الحالة). تحصل هذه المواصفات على التحقق الرسمي اعتماداً على نكهة الأسلوب الرسمي المستخدم. على سبيل المثال، في حالة TLA+، يُستخدم مدقق نموذج TLA+ (TLC) للتحقق من المواصفات. من ناحية أخرى، في حالة FOCUSST، يُستخدم مُثبِّت النظريات Isabelle/HOL عبر إطار العمل Focus on Isabelle للتحقق من مواصفات الأنظمة، راجع (Nipkow et al., 2002) و (Spichkova, 2007).

يتضمن سير العمل ضمن إطار العمل المقترح الخطوات التالية:

• إنشاء مواصفات متطلبات (غير رسمية) للنظام؛
• تحويل المواصفات غير الرسمية إلى مواصفات رسمية (نموذج) للنظام، باستخدام TLA+ أو FOCUSST؛
• التحقق من النموذج الرسمي، باستخدام مدقق نموذج TLA+ أو مُثبِّت النظريات Isabelle/HOL، على التوالي؛
• ترجمة النموذج الرسمي إلى Scala باستخدام مخطط الترجمة المقدم؛
• إضافة النموذج المحدد في Scala إلى مكتبة ScalaCheck الموسعة؛
• التحقق من مكتبة ScalaCheck الموسعة مقابل السلوك المُولَّد بواسطة مواصفات الأسلوب الرسمي.

في هذا القسم، نعرض قابلية تطبيق إطار العمل المقترح على TLA+ و FOCUSST. الهدف هو إظهار كيف يمكن تطبيق إطار العمل المقترح على أنواع عديدة من الأساليب الرسمية ذات البنية النحوية المماثلة. يقدم كل قسم فرعي مخططات تحويل برنامج غير رسمية منهجية. استخدام هذه المخططات يجعل تحويل صيغ الأسلوب الرسمي إلى أي لغة مضيفة، Scala في هذه الحالة، مهمة ميكانيكية سهلة. نبدأ بتحليل بنية وعلم دلالات TLA+. بعد ذلك، نعرض التصميم ونمذجة واجهة برمجة التطبيقات لنكهة TLA+. بعد ذلك، نعرض واجهة برمجة التطبيقات المصممة واختبارها باستخدام مثال صغير (كتلة بت واحد). يتم تطبيق عملية مماثلة على FOCUSST، مع عرض تحليل بنية وعلم دلالات FOCUSST. تقييد FOCUSST على أجزائها الرئيسية المتعلقة بالخصائص الزمنية.

**الشكل 1: إطار العمل المقترح**
[مخطط إطار العمل يعرض: صندوق الأساليب الرسمية مع جوانب التوقيت يحتوي على المواصفات والخصائص، مع أسهم التحقق الرسمي والتحويل الرسمي. أدناه، برنامج Scala مع استدعاءات واجهة برمجة التطبيقات، نماذج الحالة، BeSpaceD، مما يؤدي إلى الاختبار القائم على الخصائص وحالات الاختبار في Scala استناداً إلى الخصائص]

## 2.1 التطبيق على TLA+

يوفر TLA صندوق أدوات يتضمن بيئة تطوير متكاملة (IDE) لـ TLA+. تسمح بيئة التطوير المتكاملة بإنشاء وتحرير المواصفات، كما تعرض أخطاء التحليل النحوي ويمكن استخدامها لتشغيل مدقق نموذج TLA+. لتقليل الحمل المعرفي للمطور والمختبر، فإنها تتضمن أيضاً عارض ومستكشف تتبع الأخطاء: توفر هذه المكونات عرضاً منظماً للحالات، وتوضح كيفية تغيير الحالات/القيم في كل خطوة، وتسمح بتشغيل نظام إثبات TLA+.

صيغة TLA مثل Init ∧ [Next]v تحدد الحالات الأولية والانتقالات المسموح بها لنظام. تسمح بالانتقالات التي لا تغير قيمة v. يُطلق على هذا النوع من الانتقالات اسم انتقالات التلعثم. معظم مواصفات أنظمة TLA من النموذج Init ∧ [Next]v ∧L. يتم عرض علم دلالات هذه الصيغ في الجدول 1. يعرض الجدول 2 عوامل المنطق في TLA+ وتعييناتها في Scala، حيث يتم توفير العديد من العوامل المنطقية في Scala بواسطة BeSpaceD.

**الجدول 1: دلالات صيغة TLA**
| المصطلح | الوصف |
|---------|-------|
| Init | صيغة الحالة التي تصف الحالة (الحالات) الأولية |
| Next | صيغة الفعل التي تُضفي الطابع الرسمي على علاقة الانتقال - عادة فصل A1∨..∨An من الأفعال المحتملة (الأحداث) Ai |
| L | صيغة زمنية تؤكد شروط الحيوية |

**الجدول 2: تعيين العوامل من TLA+ إلى Scala**
| TLA+ | Scala |
|------|-------|
| /\ | AND |
| \/ | OR |
| ⇒ | IMPLIES |
| TRUE | TRUE |
| FALSE | FALSE |
| BOOLEAN | Boolean |
| {TRUE,FALSE} | List(TRUE, FALSE) |
| ≤ | lessThanEq |
| ≥ | greaterThanEq |
| > | greaterThan |
| < | lessThan |
| ≰ | lessThanEqNot |
| ≮ | lessThanNot |
| ≱ | greaterThanEqNot |
| ≯ | greaterThanNot |
| ∈ | IN |
| x == e | defined(x, e) |
| x = e | assign(x, e) |
| ∀x ∈ S : p | for {x ← S; if p} yield x |
| ∃x ∈ S : p | exists(x, S, p) |
| CHOOSE x ∈ S | choose(x, List(S)) |

في TLA+، يتم نمذجة تمثيل لتجريد نظام باستخدام النموذج القياسي. ينص النموذج القياسي على أن النظام المجرد يُوصف كمجموعة من السلوكيات، كل منها يمثل تنفيذاً محتملاً للنظام، حيث السلوك هو تسلسل من الحالات والحالة هي تعيين قيم للمتغيرات. في هذا النموذج، الحدث (الخطوة) هو الانتقال من حالة إلى التالية في سلوك. على سبيل المثال، في ساعة بت واحد، يتم تعريف الصيغ كما يلي:

```
VARIABLE b
Init == (b = 0) \/ (b = 1)
Next == \/ /\ b = 0
           /\ b' = 1
        \/ /\ b = 1
           /\ b' = 0
```

تعرف هاتان العبارتان في TLA+ Init و Next لتكونا صيغتين. لذلك، فإن الإشارة إلى init أو Next تكافئ تماماً كتابة ((b = 0) \/ (b = 1)). يُقرأ رمز المساواة = (المكتوب ==) "يُعرَّف بأنه يساوي". لتحويل هذه الصيغ إلى لغة برمجة مضيفة، من الضروري التقاط الجوانب الأساسية للصيغة المراد تحويلها، أي إنشاء مخطط ترجمة. ستتكون كل خطوة تحويل من عنصرين: أحدهما للتقاط صيغة TLA+ والآخر للتقاط دالة لغة البرمجة المقابلة. يمكن بعد ذلك استخدام المخططين معاً للقيام بالتحويل.

عناصر TLA+ للصيغ أعلاه:
```
f1 == p \/ q
f2 == \/ /\ p
         /\ q
      \/ /\ q
         /\ p
```

أي أن f1 يمثل Init، و f2 يمثل Next، و p يمثل (b=0)، و q يمثل (b=1) على التوالي. وفقاً لمخطط الترجمة، فإن ترجمة ساعة بت واحد من TLA+ إلى Scala هي كما يلي:

```scala
val b: TLAVariable = TLAVariable(IN(List(0, 1)))
val init: TLAInit = OR(defined(b,0), defined(b,1))
val next: TLANext = {
  while(true) {
    if defined(b, 0)
      return assign(b, 1)
    else
      return assign(b, 0)
  }
}
```

## 2.2 التطبيق على FOCUSST

استُلهمت لغة FOCUSST من Focus، وهو إطار عمل للمواصفات الرسمية وتطوير الأنظمة التفاعلية. في كلتا اللغتين، تستند المواصفات إلى مفهوم التدفقات، راجع (Broy and Stølen, 2001). تُكرس بنية FOCUSST بشكل خاص لتحديد الجوانب المكانية (S) والزمنية (T) بطريقة مفهومة، وهو السبب في توسيع اسم اللغة بـ ST: تدفق FOCUSST هو تعيين من الأعداد الطبيعية إلى قوائم الرسائل ضمن الفترات الزمنية المقابلة. يعرض الجدول 3 تعيينات جزئية بين عوامل FOCUSST الأساسية وتمثيلات Scala الخاصة بها.

**الجدول 3: تعيين العوامل من FOCUSST إلى Scala**
| FOCUSST | Scala |
|---------|-------|
| /\ | AND |
| \/ | OR |
| → | IMPLIES |
| TRUE | TRUE |
| FALSE | FALSE |
| BOOLEAN | Boolean |
| ≤ | lessThanEq |
| ≥ | greaterThanEq |
| > | greaterThan |
| < | lessThan |
| ≰ | lessThanEqNot |
| ≮ | lessThanNot |
| ≱ | greaterThanEqNot |
| ≯ | greaterThanNot |
| ∈ | IN |
| x == e | defined(x, e) |
| x = e | assign(x, e) |
| ∀x ∈ S : p | for {x ← S; if p} yield x |
| ∃x ∈ S : p | exists(x, S, p) |
| ⟨⟩ | List() |
| ⟨a1,...,am⟩ | a1 to am |

**الشكل 2: مواصفات FOCUSST لمتحكم الغلاية البخارية** (Spichkova, 2016)
[المواصفات تعرض وحدة المتحكم مع تدفقات الإدخال/الإخراج، والمتغيرات المحلية، والافتراضات، والضمانات للتحكم في مستوى المياه]

يستند تخطيط مواصفات FOCUSST إلى تحليل العوامل البشرية ضمن الأساليب الرسمية (Spichkova, 2012; Spichkova, 2013). يوفر الشكل 2 مثالاً على كيفية ظهور مواصفات FOCUSST. تُستخدم أقسام in و out في مواصفات FOCUSST لتحديد تدفقات الإدخال والإخراج من الأنواع المقابلة. تتضمن أقسام local و init المتغيرات المحلية والقيم الأولية، على التوالي. تتطلب FOCUSST استخدام قوالب الافتراض-الضمان، لتجنب إغفال الافتراضات غير الضرورية حول بيئة النظام. تسرد الكلمة الرئيسية asm الافتراض الذي يتوقعه المكون المحدد من بيئته، على سبيل المثال، سيعني الافتراض ts(s) أن تدفق الإدخال s يجب أن يحتوي على رسالة واحدة بالضبط لكل فترة زمنية. يتم بعد ذلك وصف سلوك المكون الذي يجب ضمانه في حالة استيفاء جميع الافتراضات في قسم المواصفات gar.

---

### Translation Notes

- **Figures referenced:** Figure 1 (Framework diagram), Figure 2 (FocusST specification)
- **Tables referenced:** Table 1 (TLA formula semantics), Table 2 (TLA+ to Scala operators), Table 3 (FocusST to Scala operators)
- **Key terms introduced:** TLC (TLA+ model checker), Isabelle/HOL, stuttering transitions, BeSpaceD, Standard Model
- **Equations:** Multiple logical formulas and code examples
- **Citations:** 6 references cited
- **Special handling:**
  - Code examples kept in original form with translation of surrounding text
  - Mathematical notation preserved
  - Tables translated with structure maintained
  - Subsection numbering preserved (2.1, 2.2)

### Quality Metrics

- Semantic equivalence: 0.88
- Technical accuracy: 0.87
- Readability: 0.86
- Glossary consistency: 0.87
- **Overall section score:** 0.87
