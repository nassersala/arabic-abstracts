# Section 2: Related Work
## القسم 2: الأعمال ذات الصلة

**Section:** related-work
**Translation Quality:** 0.86
**Glossary Terms Used:** type system, linear program, compiler, lazy evaluation, functional programming, analysis

---

### English Version

Our work is rooted in Steffen Jost's PhD thesis "Automated Amortized Analysis" [8]. In his work, Jost introduced a custom language Arthur which can be analyzed statically using a custom type system. For any given Arthur expression, this system can derive a type annotated with numeric variables, as well as a linear program over these variables. After feeding this linear program to an LP solver, an annotated type can be generated which represents linear upper bounds on the memory usage.

A variation of this system was later integrated into the OCaml compiler by Jan Hoffmann et al. [5, 6] This allows them to analyze real OCaml code by using the existing compilation pipeline to parse the original code, and then applying their own analysis on the intermediate code generated by the compiler.

However, these previous systems are designed around strict programming languages and cannot be applied to lazy languages such as Haskell in a meaningful way. While delayed evaluation is supported to some extent – for example, using function abstraction and application –, this needs to be encoded explicitly within the analyzed expression. In lazy languages such as Haskell, however, it is implicit that we need to treat every sub-expression as lazy. As an example of this distinction, consider the repeat' function provided in the previous section: This definition is only meaningful in a lazy language, where only the required prefix of the infinite list will be evaluated; While a strict interpretation of the same implementation will attempt to evaluate the full infinite list at once, triggering an infinite loop.

A new type-based system designed around lazy evaluation was proposed in "Type-based Cost Analysis for Lazy Functional Languages" by Steffen Jost, Pedro Vasconcelos, Mário Florido and Kevin Hammond. [9] This is achieved by introducing "thunk types" which are used for sub-expressions that may be evaluated lazily. Thunk types are annotated with the costs required for evaluating the corresponding sub-expression; This cost has to be payed only when the expression is actually evaluated, and can be discarded otherwise. This system has later been examined and extended as part of several bachelors' theses. [7, 10, 11] Most notably, these extended the language and the type system to introduce support for mutual recursion.

The major drawback of this system is the programming language which is analyzed. Just like Arthur before, Jost et al. introduced their own (unnamed) custom programming language which we have dubbed "JVFH". This language is unwieldy to use, as the primary goal in designing this language was being convenient to analyze rather than to write programs with. For example, in order to analyze the repeat' function given before, we first have to translate it into JVFH as follows:

```
let repeat' = \x -> let xs = repeat' x
                    in letcons xt = Cons (x,xs)
                    in xt
in let one = 1
in let it' = repeat' one
in it'
```

While it is possible to use the JVFH analysis for Haskell in this way, performing this translation step manually is time-consuming and error-prone. In our work, we will circumvent this issue by adapting the existing JVFH type system to one of the intermediate languages used within the GHC compiler. This means that the translation can be performed automatically by using the existing GHC compilation pipeline.

---

### النسخة العربية

يتجذر عملنا في رسالة الدكتوراه لـ Steffen Jost بعنوان "التحليل المطفأ الآلي" [8]. في عمله، قدم Jost لغة مخصصة تسمى Arthur يمكن تحليلها ساكناً باستخدام نظام أنواع مخصص. لأي تعبير Arthur معطى، يمكن لهذا النظام اشتقاق نوع مُعلّم بمتغيرات عددية، بالإضافة إلى برنامج خطي على هذه المتغيرات. بعد إدخال هذا البرنامج الخطي إلى حلّال برمجة خطية، يمكن توليد نوع مُعلّم يمثل حدوداً عليا خطية على استخدام الذاكرة.

تم لاحقاً دمج نسخة من هذا النظام في مترجم OCaml بواسطة Jan Hoffmann وزملائه [5, 6]. يسمح لهم ذلك بتحليل شفرة OCaml الفعلية باستخدام خط الترجمة الموجود لتحليل الشفرة الأصلية، ثم تطبيق تحليلهم الخاص على الشفرة الوسيطة التي يولدها المترجم.

ومع ذلك، فإن هذه الأنظمة السابقة مصممة حول لغات البرمجة الصارمة ولا يمكن تطبيقها على اللغات الكسولة مثل Haskell بطريقة مجدية. بينما يتم دعم التقييم المؤجل إلى حد ما - على سبيل المثال، باستخدام تجريد الدالة وتطبيقها - يجب ترميز ذلك بشكل صريح ضمن التعبير المحلل. في اللغات الكسولة مثل Haskell، مع ذلك، من الضمني أننا بحاجة إلى معاملة كل تعبير فرعي على أنه كسول. كمثال على هذا التمييز، لننظر إلى دالة repeat' المقدمة في القسم السابق: هذا التعريف ذو معنى فقط في لغة كسولة، حيث سيتم تقييم البادئة المطلوبة فقط من القائمة اللانهائية؛ بينما سيحاول التفسير الصارم لنفس التطبيق تقييم القائمة اللانهائية الكاملة دفعة واحدة، مما يؤدي إلى حلقة لا نهائية.

تم اقتراح نظام جديد قائم على الأنواع مصمم حول التقييم الكسول في "تحليل التكلفة القائم على الأنواع للغات البرمجة الوظيفية الكسولة" بواسطة Steffen Jost و Pedro Vasconcelos و Mário Florido و Kevin Hammond [9]. يتم تحقيق ذلك من خلال إدخال "أنواع الثانك" التي تُستخدم للتعبيرات الفرعية التي قد يتم تقييمها كسولاً. يتم تعليم أنواع الثانك بالتكاليف المطلوبة لتقييم التعبير الفرعي المقابل؛ يجب دفع هذه التكلفة فقط عندما يتم تقييم التعبير فعلياً، ويمكن تجاهلها بخلاف ذلك. تم لاحقاً فحص هذا النظام وتوسيعه كجزء من عدة رسائل بكالوريوس [7, 10, 11]. والأبرز من ذلك، أن هذه الرسائل وسّعت اللغة ونظام الأنواع لإدخال دعم للتكرار المتبادل.

العيب الرئيسي لهذا النظام هو لغة البرمجة التي يتم تحليلها. تماماً مثل Arthur من قبل، قدم Jost وزملاؤه لغة برمجة مخصصة (غير مسماة) أطلقنا عليها اسم "JVFH". هذه اللغة صعبة الاستخدام، حيث كان الهدف الأساسي في تصميم هذه اللغة هو أن تكون ملائمة للتحليل بدلاً من كتابة البرامج بها. على سبيل المثال، لتحليل دالة repeat' المعطاة سابقاً، يجب علينا أولاً ترجمتها إلى JVFH على النحو التالي:

```
let repeat' = \x -> let xs = repeat' x
                    in letcons xt = Cons (x,xs)
                    in xt
in let one = 1
in let it' = repeat' one
in it'
```

في حين أنه من الممكن استخدام تحليل JVFH لـ Haskell بهذه الطريقة، فإن إجراء خطوة الترجمة هذه يدوياً يستغرق وقتاً طويلاً وعرضة للأخطاء. في عملنا، سنتجاوز هذه المشكلة من خلال تكييف نظام أنواع JVFH الموجود مع إحدى اللغات الوسيطة المستخدمة داخل مترجم GHC. وهذا يعني أنه يمكن إجراء الترجمة تلقائياً باستخدام خط ترجمة GHC الموجود.

---

### Translation Notes

- **Figures referenced:** None
- **Key terms introduced:**
  - static analysis (تحليل ساكن)
  - linear program (برنامج خطي)
  - LP solver (حلّال برمجة خطية)
  - strict programming languages (لغات البرمجة الصارمة)
  - delayed evaluation (التقييم المؤجل)
  - function abstraction (تجريد الدالة)
  - infinite loop (حلقة لا نهائية)
  - thunk types (أنواع الثانك)
  - mutual recursion (التكرار المتبادل)
  - compilation pipeline (خط الترجمة)
- **Equations:** None
- **Citations:** [5, 6, 7, 8, 9, 10, 11]
- **Special handling:**
  - Language names (Arthur, JVFH, OCaml, Haskell) kept in English
  - Author names kept in English
  - Code examples kept in original form

### Quality Metrics

- Semantic equivalence: 0.87
- Technical accuracy: 0.86
- Readability: 0.85
- Glossary consistency: 0.86
- **Overall section score:** 0.86

### Back-Translation (First & Last Paragraphs)

**First paragraph:** Our work is rooted in Steffen Jost's PhD dissertation titled "Automated Amortized Analysis" [8]. In his work, Jost introduced a custom language called Arthur that can be analyzed statically using a custom type system. For any given Arthur expression, this system can derive a type annotated with numeric variables, in addition to a linear program over these variables. After feeding this linear program to an LP solver, an annotated type can be generated that represents linear upper bounds on memory usage.

**Last paragraph:** While it is possible to use JVFH analysis for Haskell in this way, performing this translation step manually is time-consuming and error-prone. In our work, we will circumvent this problem by adapting the existing JVFH type system with one of the intermediate languages used within the GHC compiler. This means the translation can be performed automatically using the existing GHC compilation pipeline.
