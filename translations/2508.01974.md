# Flow Sensitivity without Control Flow Graph: An Efficient Andersen-Style Flow-Sensitive Pointer Analysis
## الحساسية للتدفق دون رسم بياني لتدفق التحكم: تحليل مؤشرات فعال حساس للتدفق على طريقة أندرسون

**arXiv ID:** 2508.01974
**Authors:** Jiahao Zhang, Xiao Cheng, Yuxiang Lei
**Year:** 2025
**Categories:** cs.SE, cs.PL
**Translation Quality:** 0.92
**Glossary Terms Used:** pointer analysis, flow-sensitive, control flow graph, compiler optimization, alias analysis, taint analysis, constraint graph, algorithm, benchmark, optimization, framework

### English Abstract
Flow-sensitive pointer analysis constitutes an essential component of precise program analysis for accurately modeling pointer behaviors by incorporating control flows. Flow-sensitive pointer analysis is extensively used in alias analysis, taint analysis, program understanding, compiler optimization, etc. Existing flow-sensitive pointer analysis approaches, which are conducted based on control flow graphs, have significantly advanced the precision of pointer analysis via sophisticated techniques to leverage control flow information. However, they inevitably suffer from computational inefficiencies when resolving points-to information due to the inherent complex structures of control flow graphs. We present CG-FSPTA, a Flow-Sensitive Constraint Graph (FSConsG) based flow-sensitive pointer analysis to overcome the inefficiency of control-flow-graph-based analysis. CG-FSPTA uses a flow-sensitive variant to leverage the structural advantages of set-constraint graphs (which are commonly used in flow-insensitive pointer analysis) while keeping the flow sensitivity of variable definitions and uses, allowing the incorporation of sophisticated graph optimization and dynamic solving techniques. In this way, CG-FSPTA achieves significant efficiency improvements while keeping the precision of flow-sensitive analysis. Experimental evaluations on benchmark programs demonstrate that CG-FSPTA, significantly reduces both memory usage and execution time while maintaining precision. In particular, by solving in the FSConsG, CG-FSPTA achieves an average memory reduction of 33.05% and accelerates flow-sensitive pointer analysis by 7.27x compared to the state-of-art method. These experimental results underscore the efficacy of CG-FSPTA as a scalable solution to analyze large-scale software systems, establishing a robust foundation for future advancements in efficient program analysis frameworks.

### الملخص العربي
يشكل تحليل المؤشرات الحساس للتدفق مكوناً أساسياً في تحليل البرامج الدقيق لنمذجة سلوكيات المؤشرات بدقة من خلال دمج تدفقات التحكم. يُستخدم تحليل المؤشرات الحساس للتدفق على نطاق واسع في تحليل الأسماء المستعارة، وتحليل التلوث، وفهم البرامج، وتحسين المترجمات، وغيرها. لقد حققت مناهج تحليل المؤشرات الحساسة للتدفق الحالية، التي تُنفذ بناءً على الرسوم البيانية لتدفق التحكم، تقدماً كبيراً في دقة تحليل المؤشرات من خلال تقنيات متطورة للاستفادة من معلومات تدفق التحكم. ومع ذلك، فإنها تعاني حتماً من عدم الكفاءة الحسابية عند حل معلومات الإشارة إلى بسبب البنى المعقدة المتأصلة في الرسوم البيانية لتدفق التحكم. نقدم CG-FSPTA، وهو تحليل مؤشرات حساس للتدفق يعتمد على رسم بياني للقيود الحساسة للتدفق (FSConsG) للتغلب على عدم كفاءة التحليل القائم على الرسم البياني لتدفق التحكم. يستخدم CG-FSPTA متغيراً حساساً للتدفق للاستفادة من المزايا الهيكلية لرسوم القيود المجموعية (التي تُستخدم عادةً في تحليل المؤشرات غير الحساس للتدفق) مع الحفاظ على حساسية التدفق لتعريفات واستخدامات المتغيرات، مما يسمح بدمج تقنيات تحسين الرسوم البيانية المتطورة والحل الديناميكي. وبهذه الطريقة، يحقق CG-FSPTA تحسينات كبيرة في الكفاءة مع الحفاظ على دقة التحليل الحساس للتدفق. تُظهر التقييمات التجريبية على برامج المعايير القياسية أن CG-FSPTA يقلل بشكل كبير من استخدام الذاكرة ووقت التنفيذ مع الحفاظ على الدقة. على وجه الخصوص، من خلال الحل في FSConsG، يحقق CG-FSPTA متوسط تخفيض في استخدام الذاكرة بنسبة 33.05% ويسرّع تحليل المؤشرات الحساس للتدفق بمقدار 7.27 مرة مقارنة بالطريقة الأحدث. تؤكد هذه النتائج التجريبية فعالية CG-FSPTA كحل قابل للتوسع لتحليل أنظمة البرمجيات واسعة النطاق، مما يضع أساساً متيناً للتطورات المستقبلية في أطر تحليل البرامج الفعالة.

### Back-Translation (Validation)
Flow-sensitive pointer analysis forms an essential component in precise program analysis for accurately modeling pointer behaviors by integrating control flows. Flow-sensitive pointer analysis is widely used in alias analysis, taint analysis, program understanding, compiler optimization, and others. Current flow-sensitive pointer analysis approaches, which are implemented based on control flow graphs, have achieved significant advancement in pointer analysis precision through sophisticated techniques to leverage control flow information. However, they inevitably suffer from computational inefficiency when solving points-to information due to the inherent complex structures in control flow graphs. We present CG-FSPTA, a flow-sensitive pointer analysis based on a Flow-Sensitive Constraint Graph (FSConsG) to overcome the inefficiency of control-flow-graph-based analysis. CG-FSPTA uses a flow-sensitive variant to leverage the structural advantages of set-constraint graphs (which are commonly used in flow-insensitive pointer analysis) while maintaining flow sensitivity for variable definitions and uses, allowing the integration of sophisticated graph optimization techniques and dynamic solving. In this way, CG-FSPTA achieves significant efficiency improvements while maintaining the precision of flow-sensitive analysis. Experimental evaluations on benchmark programs demonstrate that CG-FSPTA significantly reduces memory usage and execution time while maintaining precision. Specifically, through solving in FSConsG, CG-FSPTA achieves an average memory reduction of 33.05% and accelerates flow-sensitive pointer analysis by 7.27 times compared to the state-of-the-art method. These experimental results confirm the effectiveness of CG-FSPTA as a scalable solution for analyzing large-scale software systems, establishing a solid foundation for future advancements in efficient program analysis frameworks.

### Translation Metrics
- Iterations: 1
- Final Score: 0.92
- Quality: High
